{"ast":null,"code":"/**\r\n * Copyright 2024 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nimport { audioContext } from \"./utils\";\nimport AudioRecordingWorklet from \"./worklets/audio-processing\";\nimport VolMeterWorket from \"./worklets/vol-meter\";\nimport { createWorketFromSrc } from \"./audioworklet-registry\";\nimport EventEmitter from \"eventemitter3\";\nfunction arrayBufferToBase64(buffer) {\n  var binary = \"\";\n  var bytes = new Uint8Array(buffer);\n  var len = bytes.byteLength;\n  for (var i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return window.btoa(binary);\n}\nexport class AudioRecorder extends EventEmitter {\n  constructor(sampleRate = 16000) {\n    super();\n    this.sampleRate = sampleRate;\n    this.stream = void 0;\n    this.audioContext = void 0;\n    this.source = void 0;\n    this.recording = false;\n    this.recordingWorklet = void 0;\n    this.vuWorklet = void 0;\n    this.starting = null;\n  }\n  async start() {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n      throw new Error(\"Could not request user media\");\n    }\n    this.starting = new Promise(async (resolve, reject) => {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      this.audioContext = await audioContext({\n        sampleRate: this.sampleRate\n      });\n      this.source = this.audioContext.createMediaStreamSource(this.stream);\n      const workletName = \"audio-recorder-worklet\";\n      const src = createWorketFromSrc(workletName, AudioRecordingWorklet);\n      await this.audioContext.audioWorklet.addModule(src);\n      this.recordingWorklet = new AudioWorkletNode(this.audioContext, workletName);\n      this.recordingWorklet.port.onmessage = async ev => {\n        // worklet processes recording floats and messages converted buffer\n        const arrayBuffer = ev.data.data.int16arrayBuffer;\n        if (arrayBuffer) {\n          const arrayBufferString = arrayBufferToBase64(arrayBuffer);\n          this.emit(\"data\", arrayBufferString);\n        }\n      };\n      this.source.connect(this.recordingWorklet);\n\n      // vu meter worklet\n      const vuWorkletName = \"vu-meter\";\n      await this.audioContext.audioWorklet.addModule(createWorketFromSrc(vuWorkletName, VolMeterWorket));\n      this.vuWorklet = new AudioWorkletNode(this.audioContext, vuWorkletName);\n      this.vuWorklet.port.onmessage = ev => {\n        this.emit(\"volume\", ev.data.volume);\n      };\n      this.source.connect(this.vuWorklet);\n      this.recording = true;\n      resolve();\n      this.starting = null;\n    });\n  }\n  stop() {\n    // its plausible that stop would be called before start completes\n    // such as if the websocket immediately hangs up\n    const handleStop = () => {\n      var _this$source, _this$stream;\n      (_this$source = this.source) === null || _this$source === void 0 ? void 0 : _this$source.disconnect();\n      (_this$stream = this.stream) === null || _this$stream === void 0 ? void 0 : _this$stream.getTracks().forEach(track => track.stop());\n      this.stream = undefined;\n      this.recordingWorklet = undefined;\n      this.vuWorklet = undefined;\n    };\n    if (this.starting) {\n      this.starting.then(handleStop);\n      return;\n    }\n    handleStop();\n  }\n}","map":{"version":3,"names":["audioContext","AudioRecordingWorklet","VolMeterWorket","createWorketFromSrc","EventEmitter","arrayBufferToBase64","buffer","binary","bytes","Uint8Array","len","byteLength","i","String","fromCharCode","window","btoa","AudioRecorder","constructor","sampleRate","stream","source","recording","recordingWorklet","vuWorklet","starting","start","navigator","mediaDevices","getUserMedia","Error","Promise","resolve","reject","audio","createMediaStreamSource","workletName","src","audioWorklet","addModule","AudioWorkletNode","port","onmessage","ev","arrayBuffer","data","int16arrayBuffer","arrayBufferString","emit","connect","vuWorkletName","volume","stop","handleStop","_this$source","_this$stream","disconnect","getTracks","forEach","track","undefined","then"],"sources":["C:/Users/prave/Repos/octane-erp/client/src/lib/audio-recorder.ts"],"sourcesContent":["/**\r\n * Copyright 2024 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { audioContext } from \"./utils\";\r\nimport AudioRecordingWorklet from \"./worklets/audio-processing\";\r\nimport VolMeterWorket from \"./worklets/vol-meter\";\r\n\r\nimport { createWorketFromSrc } from \"./audioworklet-registry\";\r\nimport EventEmitter from \"eventemitter3\";\r\n\r\nfunction arrayBufferToBase64(buffer: ArrayBuffer) {\r\n  var binary = \"\";\r\n  var bytes = new Uint8Array(buffer);\r\n  var len = bytes.byteLength;\r\n  for (var i = 0; i < len; i++) {\r\n    binary += String.fromCharCode(bytes[i]);\r\n  }\r\n  return window.btoa(binary);\r\n}\r\n\r\nexport class AudioRecorder extends EventEmitter {\r\n  stream: MediaStream | undefined;\r\n  audioContext: AudioContext | undefined;\r\n  source: MediaStreamAudioSourceNode | undefined;\r\n  recording: boolean = false;\r\n  recordingWorklet: AudioWorkletNode | undefined;\r\n  vuWorklet: AudioWorkletNode | undefined;\r\n\r\n  private starting: Promise<void> | null = null;\r\n\r\n  constructor(public sampleRate = 16000) {\r\n    super();\r\n  }\r\n\r\n  async start() {\r\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\r\n      throw new Error(\"Could not request user media\");\r\n    }\r\n\r\n    this.starting = new Promise(async (resolve, reject) => {\r\n      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      this.audioContext = await audioContext({ sampleRate: this.sampleRate });\r\n      this.source = this.audioContext.createMediaStreamSource(this.stream);\r\n\r\n      const workletName = \"audio-recorder-worklet\";\r\n      const src = createWorketFromSrc(workletName, AudioRecordingWorklet);\r\n\r\n      await this.audioContext.audioWorklet.addModule(src);\r\n      this.recordingWorklet = new AudioWorkletNode(\r\n        this.audioContext,\r\n        workletName,\r\n      );\r\n\r\n      this.recordingWorklet.port.onmessage = async (ev: MessageEvent) => {\r\n        // worklet processes recording floats and messages converted buffer\r\n        const arrayBuffer = ev.data.data.int16arrayBuffer;\r\n\r\n        if (arrayBuffer) {\r\n          const arrayBufferString = arrayBufferToBase64(arrayBuffer);\r\n          this.emit(\"data\", arrayBufferString);\r\n        }\r\n      };\r\n      this.source.connect(this.recordingWorklet);\r\n\r\n      // vu meter worklet\r\n      const vuWorkletName = \"vu-meter\";\r\n      await this.audioContext.audioWorklet.addModule(\r\n        createWorketFromSrc(vuWorkletName, VolMeterWorket),\r\n      );\r\n      this.vuWorklet = new AudioWorkletNode(this.audioContext, vuWorkletName);\r\n      this.vuWorklet.port.onmessage = (ev: MessageEvent) => {\r\n        this.emit(\"volume\", ev.data.volume);\r\n      };\r\n\r\n      this.source.connect(this.vuWorklet);\r\n      this.recording = true;\r\n      resolve();\r\n      this.starting = null;\r\n    });\r\n  }\r\n\r\n  stop() {\r\n    // its plausible that stop would be called before start completes\r\n    // such as if the websocket immediately hangs up\r\n    const handleStop = () => {\r\n      this.source?.disconnect();\r\n      this.stream?.getTracks().forEach((track) => track.stop());\r\n      this.stream = undefined;\r\n      this.recordingWorklet = undefined;\r\n      this.vuWorklet = undefined;\r\n    };\r\n    if (this.starting) {\r\n      this.starting.then(handleStop);\r\n      return;\r\n    }\r\n    handleStop();\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}