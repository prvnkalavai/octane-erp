{"ast":null,"code":"import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel } from '../../../channel';\nimport { isFieldOrDatumDef } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { getMarkStyleConfig } from '../../common';\nimport { positionOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPosition, pointPositionDefaultRef } from './position-point';\nimport * as ref from './valueref';\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\nexport function pointOrRangePosition(channel, model, {\n  defaultPos,\n  defaultPos2,\n  range\n}) {\n  if (range) {\n    return rangePosition(channel, model, {\n      defaultPos,\n      defaultPos2\n    });\n  }\n  return pointPosition(channel, model, {\n    defaultPos\n  });\n}\nexport function rangePosition(channel, model, {\n  defaultPos,\n  defaultPos2\n}) {\n  const {\n    markDef,\n    config\n  } = model;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n  const vgChannel = pos2Mixins[sizeChannel] ?\n  // If there is width/height, we need to position the marks based on the alignment.\n  vgAlignedPositionChannel(channel, markDef, config) :\n  // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n  getVgPositionChannel(channel);\n  return {\n    ...pointPosition(channel, model, {\n      defaultPos,\n      vgChannel\n    }),\n    ...pos2Mixins\n  };\n}\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nfunction pointPosition2OrSize(model, defaultPos, channel) {\n  const {\n    encoding,\n    mark,\n    markDef,\n    stack,\n    config\n  } = model;\n  const baseChannel = getMainRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n  const {\n    offset\n  } = channel in encoding || channel in markDef ? positionOffset({\n    channel,\n    markDef,\n    encoding,\n    model\n  }) : positionOffset({\n    channel: baseChannel,\n    markDef,\n    encoding,\n    model\n  });\n  if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n    const vgSizeChannel = getSizeChannel(channel);\n    const size = model.markDef[vgSizeChannel];\n    if (size != null) {\n      return {\n        [vgSizeChannel]: {\n          value: size\n        }\n      };\n    } else {\n      return {\n        [vgChannel]: {\n          field: model.getName(channel)\n        }\n      };\n    }\n  }\n  const valueRef = position2Ref({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: undefined\n  });\n  if (valueRef !== undefined) {\n    return {\n      [vgChannel]: valueRef\n    };\n  }\n  // TODO: check width/height encoding here once we add them\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n  return position2orSize(channel, markDef) || position2orSize(channel, {\n    [channel]: getMarkStyleConfig(channel, markDef, config.style),\n    [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)\n  }) || position2orSize(channel, config[mark]) || position2orSize(channel, config.mark) || {\n    [vgChannel]: pointPositionDefaultRef({\n      model,\n      defaultPos,\n      channel,\n      scaleName,\n      scale\n    })()\n  };\n}\nexport function position2Ref({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef\n}) {\n  if (isFieldOrDatumDef(channelDef) && stack &&\n  // If fieldChannel is X and channel is X2 (or Y and Y2)\n  channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'start'\n    }, {\n      offset\n    });\n  }\n  return ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    markDef,\n    config,\n    offset,\n    defaultRef\n  });\n}\nfunction position2orSize(channel, markDef) {\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  if (markDef[vgChannel] !== undefined) {\n    return {\n      [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel])\n    };\n  } else if (markDef[channel] !== undefined) {\n    return {\n      [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[channel])\n    };\n  } else if (markDef[sizeChannel]) {\n    const dimensionSize = markDef[sizeChannel];\n    if (isRelativeBandSize(dimensionSize)) {\n      log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n    } else {\n      return {\n        [sizeChannel]: ref.widthHeightValueOrSignalRef(channel, dimensionSize)\n      };\n    }\n  }\n  return undefined;\n}","map":{"version":3,"names":["getMainRangeChannel","getSecondaryRangeChannel","getSizeChannel","getVgPositionChannel","isFieldOrDatumDef","log","isRelativeBandSize","getMarkStyleConfig","positionOffset","vgAlignedPositionChannel","pointPosition","pointPositionDefaultRef","ref","pointOrRangePosition","channel","model","defaultPos","defaultPos2","range","rangePosition","markDef","config","channel2","sizeChannel","pos2Mixins","pointPosition2OrSize","vgChannel","encoding","mark","stack","baseChannel","channelDef","scaleName","scale","getScaleComponent","offset","latitude","longitude","vgSizeChannel","size","value","field","getName","valueRef","position2Ref","channel2Def","defaultRef","undefined","position2orSize","style","charAt","fieldChannel","valueRefForFieldOrDatumDef","suffix","midPointRefWithPositionInvalidTest","widthHeightValueOrSignalRef","dimensionSize","warn","message","relativeBandSizeNotSupported"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\position-range.ts"],"sourcesContent":["import type {SignalRef} from 'vega';\nimport {getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel} from '../../../channel';\nimport {isFieldOrDatumDef} from '../../../channeldef';\nimport * as log from '../../../log';\nimport {isRelativeBandSize, Mark, MarkConfig, MarkDef} from '../../../mark';\nimport {VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getMarkStyleConfig} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {positionOffset} from './offset';\nimport {vgAlignedPositionChannel} from './position-align';\nimport {pointPosition, pointPositionDefaultRef} from './position-point';\nimport * as ref from './valueref';\n\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\nexport function pointOrRangePosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  {\n    defaultPos,\n    defaultPos2,\n    range\n  }: {\n    defaultPos: 'zeroOrMin' | 'zeroOrMax' | 'mid';\n    defaultPos2: 'zeroOrMin' | 'zeroOrMax';\n    range: boolean;\n  }\n) {\n  if (range) {\n    return rangePosition(channel, model, {defaultPos, defaultPos2});\n  }\n  return pointPosition(channel, model, {defaultPos});\n}\n\nexport function rangePosition(\n  channel: 'x' | 'y' | 'theta' | 'radius',\n  model: UnitModel,\n  {\n    defaultPos,\n    defaultPos2\n  }: {\n    defaultPos: 'zeroOrMin' | 'zeroOrMax' | 'mid';\n    defaultPos2: 'zeroOrMin' | 'zeroOrMax';\n  }\n): VgEncodeEntry {\n  const {markDef, config} = model;\n  const channel2 = getSecondaryRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n\n  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n\n  const vgChannel = pos2Mixins[sizeChannel]\n    ? // If there is width/height, we need to position the marks based on the alignment.\n      vgAlignedPositionChannel(channel, markDef, config)\n    : // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n      getVgPositionChannel(channel);\n\n  return {\n    ...pointPosition(channel, model, {defaultPos, vgChannel}),\n    ...pos2Mixins\n  };\n}\n\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nfunction pointPosition2OrSize(\n  model: UnitModel,\n  defaultPos: 'zeroOrMin' | 'zeroOrMax',\n  channel: 'x2' | 'y2' | 'radius2' | 'theta2'\n) {\n  const {encoding, mark, markDef, stack, config} = model;\n\n  const baseChannel = getMainRangeChannel(channel);\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n\n  const {offset} =\n    channel in encoding || channel in markDef\n      ? positionOffset({channel, markDef, encoding, model})\n      : positionOffset({channel: baseChannel, markDef, encoding, model});\n\n  if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n    const vgSizeChannel = getSizeChannel(channel);\n\n    const size = model.markDef[vgSizeChannel];\n    if (size != null) {\n      return {\n        [vgSizeChannel]: {value: size}\n      };\n    } else {\n      return {\n        [vgChannel]: {field: model.getName(channel)}\n      };\n    }\n  }\n\n  const valueRef = position2Ref({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return {[vgChannel]: valueRef};\n  }\n\n  // TODO: check width/height encoding here once we add them\n\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n\n  return (\n    position2orSize(channel, markDef) ||\n    position2orSize(channel, {\n      [channel]: getMarkStyleConfig(channel, markDef, config.style),\n      [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)\n    }) ||\n    position2orSize(channel, config[mark]) ||\n    position2orSize(channel, config.mark) || {\n      [vgChannel]: pointPositionDefaultRef({\n        model,\n        defaultPos,\n        channel,\n        scaleName,\n        scale\n      })()\n    }\n  );\n}\n\nexport function position2Ref({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef\n}: ref.MidPointParams & {\n  channel: 'x2' | 'y2' | 'radius2' | 'theta2';\n}): VgValueRef | VgValueRef[] {\n  if (\n    isFieldOrDatumDef(channelDef) &&\n    stack &&\n    // If fieldChannel is X and channel is X2 (or Y and Y2)\n    channel.charAt(0) === stack.fieldChannel.charAt(0)\n  ) {\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {suffix: 'start'}, {offset});\n  }\n  return ref.midPointRefWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    markDef,\n    config,\n    offset,\n    defaultRef\n  });\n}\n\nfunction position2orSize(\n  channel: 'x2' | 'y2' | 'radius2' | 'theta2',\n  markDef: MarkConfig<SignalRef> | MarkDef<Mark, SignalRef>\n) {\n  const sizeChannel = getSizeChannel(channel);\n  const vgChannel = getVgPositionChannel(channel);\n  if (markDef[vgChannel] !== undefined) {\n    return {[vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel])};\n  } else if (markDef[channel] !== undefined) {\n    return {[vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[channel])};\n  } else if (markDef[sizeChannel]) {\n    const dimensionSize = markDef[sizeChannel];\n    if (isRelativeBandSize(dimensionSize)) {\n      log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n    } else {\n      return {[sizeChannel]: ref.widthHeightValueOrSignalRef(channel, dimensionSize)};\n    }\n  }\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}