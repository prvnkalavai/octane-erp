{"ast":null,"code":"/**\r\n * Copyright 2024 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst AudioRecordingWorklet = `\nclass AudioProcessingWorklet extends AudioWorkletProcessor {\n\n  // send and clear buffer every 2048 samples, \n  // which at 16khz is about 8 times a second\n  buffer = new Int16Array(2048);\n\n  // current write index\n  bufferWriteIndex = 0;\n\n  constructor() {\n    super();\n    this.hasAudio = false;\n  }\n\n  /**\n   * @param inputs Float32Array[][] [input#][channel#][sample#] so to access first inputs 1st channel inputs[0][0]\n   * @param outputs Float32Array[][]\n   */\n  process(inputs) {\n    if (inputs[0].length) {\n      const channel0 = inputs[0][0];\n      this.processChunk(channel0);\n    }\n    return true;\n  }\n\n  sendAndClearBuffer(){\n    this.port.postMessage({\n      event: \"chunk\",\n      data: {\n        int16arrayBuffer: this.buffer.slice(0, this.bufferWriteIndex).buffer,\n      },\n    });\n    this.bufferWriteIndex = 0;\n  }\n\n  processChunk(float32Array) {\n    const l = float32Array.length;\n    \n    for (let i = 0; i < l; i++) {\n      // convert float32 -1 to 1 to int16 -32768 to 32767\n      const int16Value = float32Array[i] * 32768;\n      this.buffer[this.bufferWriteIndex++] = int16Value;\n      if(this.bufferWriteIndex >= this.buffer.length) {\n        this.sendAndClearBuffer();\n      }\n    }\n\n    if(this.bufferWriteIndex >= this.buffer.length) {\n      this.sendAndClearBuffer();\n    }\n  }\n}\n`;\nexport default AudioRecordingWorklet;","map":{"version":3,"names":["AudioRecordingWorklet"],"sources":["C:/Users/prave/Repos/octane-erp/client/src/lib/worklets/audio-processing.ts"],"sourcesContent":["/**\r\n * Copyright 2024 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nconst AudioRecordingWorklet = `\r\nclass AudioProcessingWorklet extends AudioWorkletProcessor {\r\n\r\n  // send and clear buffer every 2048 samples, \r\n  // which at 16khz is about 8 times a second\r\n  buffer = new Int16Array(2048);\r\n\r\n  // current write index\r\n  bufferWriteIndex = 0;\r\n\r\n  constructor() {\r\n    super();\r\n    this.hasAudio = false;\r\n  }\r\n\r\n  /**\r\n   * @param inputs Float32Array[][] [input#][channel#][sample#] so to access first inputs 1st channel inputs[0][0]\r\n   * @param outputs Float32Array[][]\r\n   */\r\n  process(inputs) {\r\n    if (inputs[0].length) {\r\n      const channel0 = inputs[0][0];\r\n      this.processChunk(channel0);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  sendAndClearBuffer(){\r\n    this.port.postMessage({\r\n      event: \"chunk\",\r\n      data: {\r\n        int16arrayBuffer: this.buffer.slice(0, this.bufferWriteIndex).buffer,\r\n      },\r\n    });\r\n    this.bufferWriteIndex = 0;\r\n  }\r\n\r\n  processChunk(float32Array) {\r\n    const l = float32Array.length;\r\n    \r\n    for (let i = 0; i < l; i++) {\r\n      // convert float32 -1 to 1 to int16 -32768 to 32767\r\n      const int16Value = float32Array[i] * 32768;\r\n      this.buffer[this.bufferWriteIndex++] = int16Value;\r\n      if(this.bufferWriteIndex >= this.buffer.length) {\r\n        this.sendAndClearBuffer();\r\n      }\r\n    }\r\n\r\n    if(this.bufferWriteIndex >= this.buffer.length) {\r\n      this.sendAndClearBuffer();\r\n    }\r\n  }\r\n}\r\n`;\r\n\r\nexport default AudioRecordingWorklet;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,qBAAqB,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,eAAeA,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}