{"ast":null,"code":"// Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\nconst stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,]/g;\nexport default function stringify(passedObj, options = {}) {\n  const indent = JSON.stringify([1], undefined, options.indent === undefined ? 2 : options.indent).slice(2, -3);\n  const maxLength = indent === \"\" ? Infinity : options.maxLength === undefined ? 80 : options.maxLength;\n  let {\n    replacer\n  } = options;\n  return function _stringify(obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === \"function\") {\n      obj = obj.toJSON();\n    }\n    const string = JSON.stringify(obj, replacer);\n    if (string === undefined) {\n      return string;\n    }\n    const length = maxLength - currentIndent.length - reserved;\n    if (string.length <= length) {\n      const prettified = string.replace(stringOrChar, (match, stringLiteral) => {\n        return stringLiteral || `${match} `;\n      });\n      if (prettified.length <= length) {\n        return prettified;\n      }\n    }\n    if (replacer != null) {\n      obj = JSON.parse(string);\n      replacer = undefined;\n    }\n    if (typeof obj === \"object\" && obj !== null) {\n      const nextIndent = currentIndent + indent;\n      const items = [];\n      let index = 0;\n      let start;\n      let end;\n      if (Array.isArray(obj)) {\n        start = \"[\";\n        end = \"]\";\n        const {\n          length\n        } = obj;\n        for (; index < length; index++) {\n          items.push(_stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || \"null\");\n        }\n      } else {\n        start = \"{\";\n        end = \"}\";\n        const keys = Object.keys(obj);\n        const {\n          length\n        } = keys;\n        for (; index < length; index++) {\n          const key = keys[index];\n          const keyPart = `${JSON.stringify(key)}: `;\n          const value = _stringify(obj[key], nextIndent, keyPart.length + (index === length - 1 ? 0 : 1));\n          if (value !== undefined) {\n            items.push(keyPart + value);\n          }\n        }\n      }\n      if (items.length > 0) {\n        return [start, indent + items.join(`,\\n${nextIndent}`), end].join(`\\n${currentIndent}`);\n      }\n    }\n    return string;\n  }(passedObj, \"\", 0);\n}","map":{"version":3,"names":["stringOrChar","stringify","passedObj","options","indent","JSON","undefined","slice","maxLength","Infinity","replacer","_stringify","obj","currentIndent","reserved","toJSON","string","length","prettified","replace","match","stringLiteral","parse","nextIndent","items","index","start","end","Array","isArray","push","keys","Object","key","keyPart","value","join"],"sources":["C:/Users/prave/Repos/octane-erp/client/node_modules/json-stringify-pretty-compact/index.js"],"sourcesContent":["// Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\nconst stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,]/g;\n\nexport default function stringify(passedObj, options = {}) {\n  const indent = JSON.stringify(\n    [1],\n    undefined,\n    options.indent === undefined ? 2 : options.indent\n  ).slice(2, -3);\n\n  const maxLength =\n    indent === \"\"\n      ? Infinity\n      : options.maxLength === undefined\n      ? 80\n      : options.maxLength;\n\n  let { replacer } = options;\n\n  return (function _stringify(obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === \"function\") {\n      obj = obj.toJSON();\n    }\n\n    const string = JSON.stringify(obj, replacer);\n\n    if (string === undefined) {\n      return string;\n    }\n\n    const length = maxLength - currentIndent.length - reserved;\n\n    if (string.length <= length) {\n      const prettified = string.replace(\n        stringOrChar,\n        (match, stringLiteral) => {\n          return stringLiteral || `${match} `;\n        }\n      );\n      if (prettified.length <= length) {\n        return prettified;\n      }\n    }\n\n    if (replacer != null) {\n      obj = JSON.parse(string);\n      replacer = undefined;\n    }\n\n    if (typeof obj === \"object\" && obj !== null) {\n      const nextIndent = currentIndent + indent;\n      const items = [];\n      let index = 0;\n      let start;\n      let end;\n\n      if (Array.isArray(obj)) {\n        start = \"[\";\n        end = \"]\";\n        const { length } = obj;\n        for (; index < length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) ||\n              \"null\"\n          );\n        }\n      } else {\n        start = \"{\";\n        end = \"}\";\n        const keys = Object.keys(obj);\n        const { length } = keys;\n        for (; index < length; index++) {\n          const key = keys[index];\n          const keyPart = `${JSON.stringify(key)}: `;\n          const value = _stringify(\n            obj[key],\n            nextIndent,\n            keyPart.length + (index === length - 1 ? 0 : 1)\n          );\n          if (value !== undefined) {\n            items.push(keyPart + value);\n          }\n        }\n      }\n\n      if (items.length > 0) {\n        return [start, indent + items.join(`,\\n${nextIndent}`), end].join(\n          `\\n${currentIndent}`\n        );\n      }\n    }\n\n    return string;\n  })(passedObj, \"\", 0);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}