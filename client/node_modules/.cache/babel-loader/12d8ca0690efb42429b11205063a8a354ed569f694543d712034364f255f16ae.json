{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isColorChannel } from '../../channel';\nimport { title as fieldDefTitle, valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getFirstConditionValue } from './encode';\nexport const legendRules = {\n  direction: ({\n    direction\n  }) => direction,\n  format: ({\n    fieldOrDatumDef,\n    legend,\n    config\n  }) => {\n    const {\n      format,\n      formatType\n    } = legend;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n  },\n  formatType: ({\n    legend,\n    fieldOrDatumDef,\n    scaleType\n  }) => {\n    const {\n      formatType\n    } = legend;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n  gradientLength: params => {\n    const {\n      legend,\n      legendConfig\n    } = params;\n    return legend.gradientLength ?? legendConfig.gradientLength ?? defaultGradientLength(params);\n  },\n  labelOverlap: ({\n    legend,\n    legendConfig,\n    scaleType\n  }) => legend.labelOverlap ?? legendConfig.labelOverlap ?? defaultLabelOverlap(scaleType),\n  symbolType: ({\n    legend,\n    markDef,\n    channel,\n    encoding\n  }) => legend.symbolType ?? defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape),\n  title: ({\n    fieldOrDatumDef,\n    config\n  }) => fieldDefTitle(fieldOrDatumDef, config, {\n    allowDisabling: true\n  }),\n  type: ({\n    legendType,\n    scaleType,\n    channel\n  }) => {\n    if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n      if (legendType === 'gradient') {\n        return undefined;\n      }\n    } else if (legendType === 'symbol') {\n      return undefined;\n    }\n    return legendType;\n  },\n  // depended by other property, let's define upfront\n  values: ({\n    fieldOrDatumDef,\n    legend\n  }) => values(legend, fieldOrDatumDef)\n};\nexport function values(legend, fieldOrDatumDef) {\n  const vals = legend.values;\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n  return undefined;\n}\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    const shape = getFirstConditionValue(shapeChannelDef) ?? markShape;\n    if (shape) {\n      return shape;\n    }\n  }\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n    case 'arc':\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\nexport function clipHeight(legendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n  return undefined;\n}\nexport function getLegendType(params) {\n  const {\n    legend\n  } = params;\n  return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType({\n  channel,\n  timeUnit,\n  scaleType\n}) {\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n    if (isContinuousToContinuous(scaleType)) {\n      return 'gradient';\n    }\n  }\n  return 'symbol';\n}\nexport function getDirection({\n  legendConfig,\n  legendType,\n  orient,\n  legend\n}) {\n  return legend.direction ?? legendConfig[legendType ? 'gradientDirection' : 'symbolDirection'] ?? defaultDirection(orient, legendType);\n}\nexport function defaultDirection(orient, legendType) {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined:\n      // undefined = \"right\" in Vega\n      return undefined;\n    // vertical is Vega's default\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\nexport function defaultGradientLength({\n  legendConfig,\n  model,\n  direction,\n  orient,\n  scaleType\n}) {\n  const {\n    gradientHorizontalMaxLength,\n    gradientHorizontalMinLength,\n    gradientVerticalMaxLength,\n    gradientVerticalMinLength\n  } = legendConfig;\n  if (isContinuousToContinuous(scaleType)) {\n    if (direction === 'horizontal') {\n      if (orient === 'top' || orient === 'bottom') {\n        return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n      } else {\n        return gradientHorizontalMinLength;\n      }\n    } else {\n      // vertical / undefined (Vega uses vertical by default)\n      return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n    }\n  }\n  return undefined;\n}\nfunction gradientLengthSignal(model, sizeType, min, max) {\n  const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {\n    signal: `clamp(${sizeSignal}, ${min}, ${max})`\n  };\n}\nexport function defaultLabelOverlap(scaleType) {\n  if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n    return 'greedy';\n  }\n  return undefined;\n}","map":{"version":3,"names":["isArray","isColorChannel","title","fieldDefTitle","valueArray","isContinuousToContinuous","contains","getFirstDefined","isSignalRef","guideFormat","guideFormatType","getFirstConditionValue","legendRules","direction","format","fieldOrDatumDef","legend","config","formatType","type","scaleType","gradientLength","params","legendConfig","defaultGradientLength","labelOverlap","defaultLabelOverlap","symbolType","markDef","channel","encoding","defaultSymbolType","shape","allowDisabling","legendType","undefined","values","vals","mark","shapeChannelDef","markShape","clipHeight","getLegendType","defaultType","timeUnit","getDirection","orient","defaultDirection","model","gradientHorizontalMaxLength","gradientHorizontalMinLength","gradientVerticalMaxLength","gradientVerticalMinLength","gradientLengthSignal","sizeType","min","max","sizeSignal","getSizeSignalRef","signal"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\client\\node_modules\\vega-lite\\src\\compile\\legend\\properties.ts"],"sourcesContent":["import {LabelOverlap, LegendOrient, LegendType, Orientation, SignalRef, SymbolShape} from 'vega';\nimport {isArray} from 'vega-util';\nimport {isColorChannel} from '../../channel';\nimport {DatumDef, MarkPropFieldOrDatumDef, title as fieldDefTitle, TypedFieldDef, valueArray} from '../../channeldef';\nimport {Config} from '../../config';\nimport {Encoding} from '../../encoding';\nimport {Legend, LegendConfig, LegendInternal} from '../../legend';\nimport {Mark, MarkDef} from '../../mark';\nimport {isContinuousToContinuous, ScaleType} from '../../scale';\nimport {TimeUnit} from '../../timeunit';\nimport {contains, getFirstDefined} from '../../util';\nimport {isSignalRef} from '../../vega.schema';\nimport {guideFormat, guideFormatType} from '../format';\nimport {Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {NonPositionScaleChannel} from './../../channel';\nimport {LegendComponentProps} from './component';\nimport {getFirstConditionValue} from './encode';\n\nexport interface LegendRuleParams {\n  legend: LegendInternal;\n  channel: NonPositionScaleChannel;\n  model: UnitModel;\n  markDef: MarkDef<Mark, SignalRef>;\n  encoding: Encoding<string>;\n  fieldOrDatumDef: MarkPropFieldOrDatumDef<string>;\n  legendConfig: LegendConfig<SignalRef>;\n  config: Config<SignalRef>;\n  scaleType: ScaleType;\n  orient: LegendOrient;\n  legendType: LegendType;\n  direction: Orientation;\n}\n\nexport const legendRules: {\n  [k in keyof LegendComponentProps]?: (params: LegendRuleParams) => LegendComponentProps[k];\n} = {\n  direction: ({direction}) => direction,\n\n  format: ({fieldOrDatumDef, legend, config}) => {\n    const {format, formatType} = legend;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n  },\n\n  formatType: ({legend, fieldOrDatumDef, scaleType}) => {\n    const {formatType} = legend;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n\n  gradientLength: params => {\n    const {legend, legendConfig} = params;\n    return legend.gradientLength ?? legendConfig.gradientLength ?? defaultGradientLength(params);\n  },\n\n  labelOverlap: ({legend, legendConfig, scaleType}) =>\n    legend.labelOverlap ?? legendConfig.labelOverlap ?? defaultLabelOverlap(scaleType),\n\n  symbolType: ({legend, markDef, channel, encoding}) =>\n    legend.symbolType ?? defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape),\n\n  title: ({fieldOrDatumDef, config}) => fieldDefTitle(fieldOrDatumDef, config, {allowDisabling: true}),\n\n  type: ({legendType, scaleType, channel}) => {\n    if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n      if (legendType === 'gradient') {\n        return undefined;\n      }\n    } else if (legendType === 'symbol') {\n      return undefined;\n    }\n    return legendType;\n  }, // depended by other property, let's define upfront\n\n  values: ({fieldOrDatumDef, legend}) => values(legend, fieldOrDatumDef)\n};\n\nexport function values(legend: LegendInternal, fieldOrDatumDef: TypedFieldDef<string> | DatumDef) {\n  const vals = legend.values;\n\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n  return undefined;\n}\n\nexport function defaultSymbolType(\n  mark: Mark,\n  channel: NonPositionScaleChannel,\n  shapeChannelDef: Encoding<string>['shape'],\n  markShape: SymbolShape | SignalRef\n): SymbolShape | SignalRef {\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    const shape = getFirstConditionValue<string>(shapeChannelDef) ?? markShape;\n    if (shape) {\n      return shape;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n    case 'arc':\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\n\nexport function clipHeight(legendType: LegendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n  return undefined;\n}\n\nexport function getLegendType(params: {\n  legend: LegendInternal;\n  channel: NonPositionScaleChannel;\n  timeUnit?: TimeUnit;\n  scaleType: ScaleType;\n}): LegendType {\n  const {legend} = params;\n\n  return getFirstDefined(legend.type, defaultType(params));\n}\n\nexport function defaultType({\n  channel,\n  timeUnit,\n  scaleType\n}: {\n  channel: NonPositionScaleChannel;\n  timeUnit?: TimeUnit;\n  scaleType: ScaleType;\n}): LegendType {\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n\n    if (isContinuousToContinuous(scaleType)) {\n      return 'gradient';\n    }\n  }\n  return 'symbol';\n}\n\nexport function getDirection({\n  legendConfig,\n  legendType,\n  orient,\n  legend\n}: {\n  orient: LegendOrient;\n  legendConfig: LegendConfig<SignalRef>;\n  legendType: LegendType;\n  legend: Legend<SignalRef>;\n}): Orientation {\n  return (\n    legend.direction ??\n    legendConfig[legendType ? 'gradientDirection' : 'symbolDirection'] ??\n    defaultDirection(orient, legendType)\n  );\n}\n\nexport function defaultDirection(orient: LegendOrient, legendType: LegendType): 'horizontal' | undefined {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined: // undefined = \"right\" in Vega\n      return undefined; // vertical is Vega's default\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\n\nexport function defaultGradientLength({\n  legendConfig,\n  model,\n  direction,\n  orient,\n  scaleType\n}: {\n  scaleType: ScaleType;\n  direction: Orientation;\n  orient: LegendOrient;\n  model: Model;\n  legendConfig: LegendConfig<SignalRef>;\n}) {\n  const {\n    gradientHorizontalMaxLength,\n    gradientHorizontalMinLength,\n    gradientVerticalMaxLength,\n    gradientVerticalMinLength\n  } = legendConfig;\n  if (isContinuousToContinuous(scaleType)) {\n    if (direction === 'horizontal') {\n      if (orient === 'top' || orient === 'bottom') {\n        return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n      } else {\n        return gradientHorizontalMinLength;\n      }\n    } else {\n      // vertical / undefined (Vega uses vertical by default)\n      return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n    }\n  }\n  return undefined;\n}\n\nfunction gradientLengthSignal(model: Model, sizeType: 'width' | 'height', min: number, max: number) {\n  const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {signal: `clamp(${sizeSignal}, ${min}, ${max})`};\n}\n\nexport function defaultLabelOverlap(scaleType: ScaleType): LabelOverlap {\n  if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n    return 'greedy';\n  }\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}