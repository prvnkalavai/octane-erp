{"ast":null,"code":"import { parseSelector } from 'vega-event-selector';\nimport { array, isObject, isString, stringValue } from 'vega-util';\nimport { isTimerSelection, selectionCompilers, STORE } from '.';\nimport { warn } from '../../log';\nimport { duplicate, entries, replacePathInField, varName } from '../../util';\nimport { OutputNode } from '../data/dataflow';\nimport { FilterNode } from '../data/filter';\nimport { DataSourceType } from '../../data';\nimport { MULTIPLE_TIMER_ANIMATION_SELECTION, selectionAsScaleDomainWithoutField, selectionAsScaleDomainWrongEncodings } from '../../log/message';\nexport function parseUnitSelection(model, selDefs) {\n  const selCmpts = {};\n  const selectionConfig = model.config.selection;\n  if (!selDefs || !selDefs.length) return selCmpts;\n  let nTimerSelections = 0;\n  for (const def of selDefs) {\n    const name = varName(def.name);\n    const selDef = def.select;\n    const type = isString(selDef) ? selDef : selDef.type;\n    const defaults = isObject(selDef) ? duplicate(selDef) : {\n      type\n    };\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n    const cfg = selectionConfig[type];\n    for (const key in cfg) {\n      // Project transform applies its defaults.\n      if (key === 'fields' || key === 'encodings') {\n        continue;\n      }\n      if (key === 'mark') {\n        defaults.mark = {\n          ...cfg.mark,\n          ...defaults.mark\n        };\n      }\n      if (defaults[key] === undefined || defaults[key] === true) {\n        defaults[key] = duplicate(cfg[key] ?? defaults[key]);\n      }\n    }\n    const selCmpt = selCmpts[name] = {\n      ...defaults,\n      name,\n      type,\n      init: def.value,\n      bind: def.bind,\n      events: isString(defaults.on) ? parseSelector(defaults.on, 'scope') : array(duplicate(defaults.on))\n    };\n    if (isTimerSelection(selCmpt)) {\n      nTimerSelections++;\n      // check for multiple timer selections and ignore all but the first one\n      if (nTimerSelections > 1) {\n        delete selCmpts[name];\n        continue;\n      }\n    }\n    const def_ = duplicate(def); // defensive copy to prevent compilers from causing side effects\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.parse) {\n        c.parse(model, selCmpt, def_);\n      }\n    }\n  }\n  if (nTimerSelections > 1) {\n    // if multiple timer selections were found, issue a warning\n    warn(MULTIPLE_TIMER_ANIMATION_SELECTION);\n  }\n  return selCmpts;\n}\nexport function parseSelectionPredicate(model, pred, dfnode, datum = 'datum') {\n  const name = isString(pred) ? pred : pred.param;\n  const vname = varName(name);\n  const store = stringValue(vname + STORE);\n  let selCmpt;\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat as a variable parameter and coerce to boolean.\n    return `!!${vname}`;\n  }\n  if (selCmpt.project.timeUnit) {\n    const child = dfnode ?? model.component.data.raw;\n    const tunode = selCmpt.project.timeUnit.clone();\n    if (child.parent) {\n      tunode.insertAsParentOf(child);\n    } else {\n      child.parent = tunode;\n    }\n  }\n  const fn = selCmpt.project.hasSelectionId ? 'vlSelectionIdTest(' : 'vlSelectionTest(';\n  const resolve = selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`;\n  const test = `${fn}${store}, ${datum}${resolve}`;\n  const length = `length(data(${store}))`;\n  return pred.empty === false ? `${length} && ${test}` : `!${length} || ${test}`;\n}\nexport function parseSelectionExtent(model, name, extent) {\n  const vname = varName(name);\n  const encoding = extent.encoding;\n  let field = extent.field;\n  let selCmpt;\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat it as a variable parameter.\n    return vname;\n  }\n  if (!encoding && !field) {\n    field = selCmpt.project.items[0].field;\n    if (selCmpt.project.items.length > 1) {\n      warn(selectionAsScaleDomainWithoutField(field));\n    }\n  } else if (encoding && !field) {\n    const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n    if (!encodings.length || encodings.length > 1) {\n      field = selCmpt.project.items[0].field;\n      warn(selectionAsScaleDomainWrongEncodings(encodings, encoding, extent, field));\n    } else {\n      field = encodings[0].field;\n    }\n  }\n  return `${selCmpt.name}[${stringValue(replacePathInField(field))}]`;\n}\nexport function materializeSelections(model, main) {\n  for (const [selection, selCmpt] of entries(model.component.selection ?? {})) {\n    const lookupName = model.getName(`lookup_${selection}`);\n    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main, model, {\n      param: selection\n    }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n  }\n}","map":{"version":3,"names":["parseSelector","array","isObject","isString","stringValue","isTimerSelection","selectionCompilers","STORE","warn","duplicate","entries","replacePathInField","varName","OutputNode","FilterNode","DataSourceType","MULTIPLE_TIMER_ANIMATION_SELECTION","selectionAsScaleDomainWithoutField","selectionAsScaleDomainWrongEncodings","parseUnitSelection","model","selDefs","selCmpts","selectionConfig","config","selection","length","nTimerSelections","def","name","selDef","select","type","defaults","cfg","key","mark","undefined","selCmpt","init","value","bind","events","on","def_","c","defined","parse","parseSelectionPredicate","pred","dfnode","datum","param","vname","store","getSelectionComponent","e","project","timeUnit","child","component","data","raw","tunode","clone","parent","insertAsParentOf","fn","hasSelectionId","resolve","test","empty","parseSelectionExtent","extent","encoding","field","items","encodings","filter","p","channel","materializeSelections","main","lookupName","getName","outputNodes","materialized","Lookup","outputNodeRefCounts"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\node_modules\\vega-lite\\src\\compile\\selection\\parse.ts"],"sourcesContent":["import {parseSelector} from 'vega-event-selector';\nimport {array, isObject, isString, stringValue} from 'vega-util';\nimport {isTimerSelection, selectionCompilers, SelectionComponent, STORE} from '.';\nimport {warn} from '../../log';\nimport {BaseSelectionConfig, SelectionParameter, ParameterExtent} from '../../selection';\nimport {Dict, duplicate, entries, replacePathInField, varName} from '../../util';\nimport {DataFlowNode, OutputNode} from '../data/dataflow';\nimport {FilterNode} from '../data/filter';\nimport {Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {DataSourceType} from '../../data';\nimport {ParameterPredicate} from '../../predicate';\nimport {\n  MULTIPLE_TIMER_ANIMATION_SELECTION,\n  selectionAsScaleDomainWithoutField,\n  selectionAsScaleDomainWrongEncodings\n} from '../../log/message';\n\nexport function parseUnitSelection(model: UnitModel, selDefs: SelectionParameter[]) {\n  const selCmpts: Dict<SelectionComponent<any /* this has to be \"any\" so typing won't fail in test files*/>> = {};\n  const selectionConfig = model.config.selection;\n\n  if (!selDefs || !selDefs.length) return selCmpts;\n\n  let nTimerSelections = 0;\n\n  for (const def of selDefs) {\n    const name = varName(def.name);\n    const selDef = def.select;\n    const type = isString(selDef) ? selDef : selDef.type;\n    const defaults: BaseSelectionConfig = isObject(selDef) ? duplicate(selDef) : {type};\n\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n    const cfg = selectionConfig[type];\n    for (const key in cfg) {\n      // Project transform applies its defaults.\n      if (key === 'fields' || key === 'encodings') {\n        continue;\n      }\n\n      if (key === 'mark') {\n        (defaults as any).mark = {...(cfg as any).mark, ...(defaults as any).mark};\n      }\n\n      if ((defaults as any)[key] === undefined || (defaults as any)[key] === true) {\n        (defaults as any)[key] = duplicate((cfg as any)[key] ?? (defaults as any)[key]);\n      }\n    }\n\n    const selCmpt: SelectionComponent<any> = (selCmpts[name] = {\n      ...defaults,\n      name,\n      type,\n      init: def.value,\n      bind: def.bind,\n      events: isString(defaults.on) ? parseSelector(defaults.on, 'scope') : array(duplicate(defaults.on))\n    } as any);\n\n    if (isTimerSelection(selCmpt)) {\n      nTimerSelections++;\n      // check for multiple timer selections and ignore all but the first one\n      if (nTimerSelections > 1) {\n        delete selCmpts[name];\n        continue;\n      }\n    }\n\n    const def_ = duplicate(def); // defensive copy to prevent compilers from causing side effects\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.parse) {\n        c.parse(model, selCmpt, def_);\n      }\n    }\n  }\n\n  if (nTimerSelections > 1) {\n    // if multiple timer selections were found, issue a warning\n    warn(MULTIPLE_TIMER_ANIMATION_SELECTION);\n  }\n\n  return selCmpts;\n}\n\nexport function parseSelectionPredicate(\n  model: Model,\n  pred: ParameterPredicate,\n  dfnode?: DataFlowNode,\n  datum = 'datum'\n): string {\n  const name = isString(pred) ? pred : pred.param;\n  const vname = varName(name);\n  const store = stringValue(vname + STORE);\n  let selCmpt;\n\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat as a variable parameter and coerce to boolean.\n    return `!!${vname}`;\n  }\n\n  if (selCmpt.project.timeUnit) {\n    const child = dfnode ?? model.component.data.raw;\n    const tunode = selCmpt.project.timeUnit.clone();\n    if (child.parent) {\n      tunode.insertAsParentOf(child);\n    } else {\n      child.parent = tunode;\n    }\n  }\n\n  const fn = selCmpt.project.hasSelectionId ? 'vlSelectionIdTest(' : 'vlSelectionTest(';\n  const resolve = selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`;\n  const test = `${fn}${store}, ${datum}${resolve}`;\n  const length = `length(data(${store}))`;\n\n  return pred.empty === false ? `${length} && ${test}` : `!${length} || ${test}`;\n}\n\nexport function parseSelectionExtent(model: Model, name: string, extent: ParameterExtent) {\n  const vname = varName(name);\n  const encoding = (extent as any).encoding;\n  let field = (extent as any).field;\n  let selCmpt;\n\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat it as a variable parameter.\n    return vname;\n  }\n\n  if (!encoding && !field) {\n    field = selCmpt.project.items[0].field;\n    if (selCmpt.project.items.length > 1) {\n      warn(selectionAsScaleDomainWithoutField(field));\n    }\n  } else if (encoding && !field) {\n    const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n    if (!encodings.length || encodings.length > 1) {\n      field = selCmpt.project.items[0].field;\n      warn(selectionAsScaleDomainWrongEncodings(encodings, encoding, extent, field));\n    } else {\n      field = encodings[0].field;\n    }\n  }\n\n  return `${selCmpt.name}[${stringValue(replacePathInField(field))}]`;\n}\n\nexport function materializeSelections(model: UnitModel, main: OutputNode) {\n  for (const [selection, selCmpt] of entries(model.component.selection ?? {})) {\n    const lookupName = model.getName(`lookup_${selection}`);\n    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(\n      new FilterNode(main, model, {param: selection}),\n      lookupName,\n      DataSourceType.Lookup,\n      model.component.data.outputNodeRefCounts\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}