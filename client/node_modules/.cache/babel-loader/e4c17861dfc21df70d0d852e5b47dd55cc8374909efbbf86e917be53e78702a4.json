{"ast":null,"code":"import { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel, isXorY, THETA, RADIUS } from '../../../channel';\nimport { defaultTitle, getFieldDef, getFormatMixins, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { entries } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { binFormatExpression, formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model, opt = {}) {\n  const {\n    encoding,\n    markDef,\n    config,\n    stack\n  } = model;\n  const channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {\n      tooltip: tooltipRefForEncoding({\n        tooltip: channelDef\n      }, stack, config, opt)\n    };\n  } else {\n    const datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n    const mainRefFn = cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = textRef(cDef, config, datum);\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n      let markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n      if (markTooltip === true) {\n        markTooltip = {\n          content: 'encoding'\n        };\n      }\n      if (isString(markTooltip)) {\n        return {\n          value: markTooltip\n        };\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (isSignalRef(markTooltip)) {\n          return markTooltip;\n        } else if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, stack, config, opt);\n        } else {\n          return {\n            signal: datum\n          };\n        }\n      }\n      return undefined;\n    };\n    return wrapCondition({\n      model,\n      channelDef,\n      vgChannel: 'tooltip',\n      mainRefFn,\n      invalidValueRef: undefined // tooltip encoding doesn't have continuous scales and thus can't have invalid values\n    });\n  }\n}\nexport function tooltipData(encoding, stack, config, {\n  reactiveGeom\n} = {}) {\n  const formatConfig = {\n    ...config,\n    ...config.tooltipFormat\n  };\n  const toSkip = new Set();\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tuples = [];\n  function add(fDef, channel) {\n    const mainChannel = getMainRangeChannel(channel);\n    const fieldDef = isTypedFieldDef(fDef) ? fDef : {\n      ...fDef,\n      type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n    };\n    const title = fieldDef.title || defaultTitle(fieldDef, formatConfig);\n    const key = array(title).join(', ').replaceAll(/\"/g, '\\\\\"');\n    let value;\n    if (isXorY(channel)) {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {\n          expr\n        });\n        const endField = vgField(fieldDef2, {\n          expr\n        });\n        const {\n          format,\n          formatType\n        } = getFormatMixins(fieldDef);\n        value = binFormatExpression(startField, endField, format, formatType, formatConfig);\n        toSkip.add(channel2);\n      }\n    }\n    if ((isXorY(channel) || channel === THETA || channel === RADIUS) && stack && stack.fieldChannel === channel && stack.offset === 'normalize') {\n      const {\n        format,\n        formatType\n      } = getFormatMixins(fieldDef);\n      value = formatSignalRef({\n        fieldOrDatumDef: fieldDef,\n        format,\n        formatType,\n        expr,\n        config: formatConfig,\n        normalizeStack: true\n      }).signal;\n    }\n    value ?? (value = textRef(fieldDef, formatConfig, expr).signal);\n    tuples.push({\n      channel,\n      key,\n      value\n    });\n  }\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n  const out = {};\n  for (const {\n    channel,\n    key,\n    value\n  } of tuples) {\n    if (!toSkip.has(channel) && !out[key]) {\n      out[key] = value;\n    }\n  }\n  return out;\n}\nexport function tooltipRefForEncoding(encoding, stack, config, {\n  reactiveGeom\n} = {}) {\n  const data = tooltipData(encoding, stack, config, {\n    reactiveGeom\n  });\n  const keyValues = entries(data).map(([key, value]) => `\"${key}\": ${value}`);\n  return keyValues.length > 0 ? {\n    signal: `{${keyValues.join(', ')}}`\n  } : undefined;\n}","map":{"version":3,"names":["array","isArray","isObject","isString","isBinned","getMainRangeChannel","isXorY","THETA","RADIUS","defaultTitle","getFieldDef","getFormatMixins","hasConditionalFieldDef","isFieldDef","isTypedFieldDef","vgField","forEach","entries","isSignalRef","getMarkPropOrConfig","binFormatExpression","formatSignalRef","wrapCondition","textRef","tooltip","model","opt","encoding","markDef","config","stack","channelDef","tooltipRefForEncoding","datum","reactiveGeom","mainRefFn","cDef","tooltipRefFromChannelDef","undefined","markTooltip","content","value","signal","vgChannel","invalidValueRef","tooltipData","formatConfig","tooltipFormat","toSkip","Set","expr","tuples","add","fDef","channel","mainChannel","fieldDef","type","title","key","join","replaceAll","channel2","fieldDef2","bin","startField","endField","format","formatType","fieldChannel","offset","fieldOrDatumDef","normalizeStack","push","condition","out","has","data","keyValues","map","length"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\tooltip.ts"],"sourcesContent":["import {array, isArray, isObject, isString} from 'vega-util';\nimport {isBinned} from '../../../bin';\nimport {getMainRangeChannel, isXorY, Channel, THETA, RADIUS} from '../../../channel';\nimport {\n  defaultTitle,\n  getFieldDef,\n  getFormatMixins,\n  hasConditionalFieldDef,\n  isFieldDef,\n  isTypedFieldDef,\n  SecondaryFieldDef,\n  TypedFieldDef,\n  vgField\n} from '../../../channeldef';\nimport {Config} from '../../../config';\nimport {Encoding, forEach} from '../../../encoding';\nimport {StackProperties} from '../../../stack';\nimport {Dict, entries} from '../../../util';\nimport {isSignalRef} from '../../../vega.schema';\nimport {getMarkPropOrConfig} from '../../common';\nimport {binFormatExpression, formatSignalRef} from '../../format';\nimport {UnitModel} from '../../unit';\nimport {wrapCondition} from './conditional';\nimport {textRef} from './text';\n\nexport function tooltip(model: UnitModel, opt: {reactiveGeom?: boolean} = {}) {\n  const {encoding, markDef, config, stack} = model;\n  const channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {tooltip: tooltipRefForEncoding({tooltip: channelDef}, stack, config, opt)};\n  } else {\n    const datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n    const mainRefFn = (cDef: Encoding<string>['tooltip']) => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = textRef(cDef, config, datum);\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n\n      let markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n\n      if (markTooltip === true) {\n        markTooltip = {content: 'encoding'};\n      }\n\n      if (isString(markTooltip)) {\n        return {value: markTooltip};\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (isSignalRef(markTooltip)) {\n          return markTooltip;\n        } else if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, stack, config, opt);\n        } else {\n          return {signal: datum};\n        }\n      }\n\n      return undefined;\n    };\n\n    return wrapCondition({\n      model,\n      channelDef,\n      vgChannel: 'tooltip',\n      mainRefFn,\n      invalidValueRef: undefined // tooltip encoding doesn't have continuous scales and thus can't have invalid values\n    });\n  }\n}\n\nexport function tooltipData(\n  encoding: Encoding<string>,\n  stack: StackProperties,\n  config: Config,\n  {reactiveGeom}: {reactiveGeom?: boolean} = {}\n) {\n  const formatConfig = {...config, ...config.tooltipFormat};\n  const toSkip = new Set();\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tuples: {channel: Channel; key: string; value: string}[] = [];\n\n  function add(fDef: TypedFieldDef<string> | SecondaryFieldDef<string>, channel: Channel) {\n    const mainChannel = getMainRangeChannel(channel);\n\n    const fieldDef: TypedFieldDef<string> = isTypedFieldDef(fDef)\n      ? fDef\n      : {\n          ...fDef,\n          type: (encoding[mainChannel] as TypedFieldDef<any>).type // for secondary field def, copy type from main channel\n        };\n\n    const title = fieldDef.title || defaultTitle(fieldDef, formatConfig);\n    const key = array(title).join(', ').replaceAll(/\"/g, '\\\\\"');\n\n    let value: string;\n\n    if (isXorY(channel)) {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {expr});\n        const endField = vgField(fieldDef2, {expr});\n        const {format, formatType} = getFormatMixins(fieldDef);\n        value = binFormatExpression(startField, endField, format, formatType, formatConfig);\n        toSkip.add(channel2);\n      }\n    }\n\n    if (\n      (isXorY(channel) || channel === THETA || channel === RADIUS) &&\n      stack &&\n      stack.fieldChannel === channel &&\n      stack.offset === 'normalize'\n    ) {\n      const {format, formatType} = getFormatMixins(fieldDef);\n      value = formatSignalRef({\n        fieldOrDatumDef: fieldDef,\n        format,\n        formatType,\n        expr,\n        config: formatConfig,\n        normalizeStack: true\n      }).signal;\n    }\n\n    value ??= textRef(fieldDef, formatConfig, expr).signal;\n\n    tuples.push({channel, key, value});\n  }\n\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n\n  const out: Dict<string> = {};\n  for (const {channel, key, value} of tuples) {\n    if (!toSkip.has(channel) && !out[key]) {\n      out[key] = value;\n    }\n  }\n\n  return out;\n}\n\nexport function tooltipRefForEncoding(\n  encoding: Encoding<string>,\n  stack: StackProperties,\n  config: Config,\n  {reactiveGeom}: {reactiveGeom?: boolean} = {}\n) {\n  const data = tooltipData(encoding, stack, config, {reactiveGeom});\n\n  const keyValues = entries(data).map(([key, value]) => `\"${key}\": ${value}`);\n  return keyValues.length > 0 ? {signal: `{${keyValues.join(', ')}}`} : undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}