{"ast":null,"code":"import { array, isArray, stringValue } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { getFirstDefined, hasProperty, isEmpty, varName } from '../../util';\nimport { applyMarkConfig, signalOrValueRef } from '../common';\nimport { formatCustomType, isCustomFormatType } from '../format';\nimport * as mixins from '../mark/encode';\nimport { STORE } from '../selection';\nexport const legendEncodeRules = {\n  symbols,\n  gradient,\n  labels,\n  entries\n};\nexport function symbols(symbolsSpec, {\n  fieldOrDatumDef,\n  model,\n  channel,\n  legendCmpt,\n  legendType\n}) {\n  if (legendType !== 'symbol') {\n    return undefined;\n  }\n  const {\n    markDef,\n    encoding,\n    config,\n    mark\n  } = model;\n  const filled = markDef.filled && mark !== 'trail';\n  let out = {\n    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),\n    ...mixins.color(model, {\n      filled\n    })\n  }; // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n  const symbolOpacity = legendCmpt.get('symbolOpacity') ?? config.legend.symbolOpacity;\n  const symbolFillColor = legendCmpt.get('symbolFillColor') ?? config.legend.symbolFillColor;\n  const symbolStrokeColor = legendCmpt.get('symbolStrokeColor') ?? config.legend.symbolStrokeColor;\n  const opacity = symbolOpacity === undefined ? getMaxValue(encoding.opacity) ?? markDef.opacity : undefined;\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || filled && channel === COLOR) {\n      delete out.fill;\n    } else if (hasProperty(out.fill, 'field')) {\n      // For others, set fill to some opaque value (or nothing if a color is already set)\n      if (symbolFillColor) {\n        delete out.fill;\n      } else {\n        out.fill = signalOrValueRef(config.legend.symbolBaseFillColor ?? 'black');\n        out.fillOpacity = signalOrValueRef(opacity ?? 1);\n      }\n    } else if (isArray(out.fill)) {\n      const fill = getFirstConditionValue(encoding.fill ?? encoding.color) ?? markDef.fill ?? (filled && markDef.color);\n      if (fill) {\n        out.fill = signalOrValueRef(fill);\n      }\n    }\n  }\n  if (out.stroke) {\n    if (channel === 'stroke' || !filled && channel === COLOR) {\n      delete out.stroke;\n    } else if (hasProperty(out.stroke, 'field') || symbolStrokeColor) {\n      // For others, remove stroke field\n      delete out.stroke;\n    } else if (isArray(out.stroke)) {\n      const stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n      if (stroke) {\n        out.stroke = {\n          value: stroke\n        };\n      }\n    }\n  }\n  if (channel !== OPACITY) {\n    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n    if (condition) {\n      out.opacity = [{\n        test: condition,\n        ...signalOrValueRef(opacity ?? 1)\n      }, signalOrValueRef(config.legend.unselectedOpacity)];\n    } else if (opacity) {\n      out.opacity = signalOrValueRef(opacity);\n    }\n  }\n  out = {\n    ...out,\n    ...symbolsSpec\n  };\n  return isEmpty(out) ? undefined : out;\n}\nexport function gradient(gradientSpec, {\n  model,\n  legendType,\n  legendCmpt\n}) {\n  if (legendType !== 'gradient') {\n    return undefined;\n  }\n  const {\n    config,\n    markDef,\n    encoding\n  } = model;\n  let out = {};\n  const gradientOpacity = legendCmpt.get('gradientOpacity') ?? config.legend.gradientOpacity;\n  const opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = signalOrValueRef(opacity);\n  }\n  out = {\n    ...out,\n    ...gradientSpec\n  };\n  return isEmpty(out) ? undefined : out;\n}\nexport function labels(specifiedlabelsSpec, {\n  fieldOrDatumDef,\n  model,\n  channel,\n  legendCmpt\n}) {\n  const legend = model.legend(channel) || {};\n  const config = model.config;\n  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n  const opacity = condition ? [{\n    test: condition,\n    value: 1\n  }, {\n    value: config.legend.unselectedOpacity\n  }] : undefined;\n  const {\n    format,\n    formatType\n  } = legend;\n  let text = undefined;\n  if (isCustomFormatType(formatType)) {\n    text = formatCustomType({\n      fieldOrDatumDef,\n      field: 'datum.value',\n      format,\n      formatType,\n      config\n    });\n  } else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (fieldOrDatumDef.type === 'quantitative' && config.numberFormatType) {\n      text = formatCustomType({\n        fieldOrDatumDef,\n        field: 'datum.value',\n        format: config.numberFormat,\n        formatType: config.numberFormatType,\n        config\n      });\n    } else if (fieldOrDatumDef.type === 'temporal' && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === undefined) {\n      text = formatCustomType({\n        fieldOrDatumDef,\n        field: 'datum.value',\n        format: config.timeFormat,\n        formatType: config.timeFormatType,\n        config\n      });\n    }\n  }\n  const labelsSpec = {\n    ...(opacity ? {\n      opacity\n    } : {}),\n    ...(text ? {\n      text\n    } : {}),\n    ...specifiedlabelsSpec\n  };\n  return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\nexport function entries(entriesSpec, {\n  legendCmpt\n}) {\n  const selections = legendCmpt.get('selections');\n  return selections?.length ? {\n    ...entriesSpec,\n    fill: {\n      value: 'transparent'\n    }\n  } : entriesSpec;\n}\nfunction getMaxValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));\n}\nexport function getFirstConditionValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => {\n    return getFirstDefined(v, conditionalDef.value);\n  });\n}\nfunction getConditionValue(channelDef, reducer) {\n  if (hasConditionalValueDef(channelDef)) {\n    return array(channelDef.condition).reduce(reducer, channelDef.value);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value;\n  }\n  return undefined;\n}\nfunction selectedCondition(model, legendCmpt, fieldDef) {\n  const selections = legendCmpt.get('selections');\n  if (!selections?.length) return undefined;\n  const field = stringValue(fieldDef.field);\n  return selections.map(name => {\n    const store = stringValue(varName(name) + STORE);\n    return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n  }).join(' || ');\n}","map":{"version":3,"names":["array","isArray","stringValue","COLOR","OPACITY","hasConditionalValueDef","isFieldDef","isValueDef","FILL_STROKE_CONFIG","getFirstDefined","hasProperty","isEmpty","varName","applyMarkConfig","signalOrValueRef","formatCustomType","isCustomFormatType","mixins","STORE","legendEncodeRules","symbols","gradient","labels","entries","symbolsSpec","fieldOrDatumDef","model","channel","legendCmpt","legendType","undefined","markDef","encoding","config","mark","filled","out","color","symbolOpacity","get","legend","symbolFillColor","symbolStrokeColor","opacity","getMaxValue","fill","symbolBaseFillColor","fillOpacity","getFirstConditionValue","stroke","value","condition","selectedCondition","test","unselectedOpacity","gradientSpec","gradientOpacity","specifiedlabelsSpec","format","formatType","text","field","customFormatTypes","type","numberFormatType","numberFormat","timeFormatType","timeUnit","timeFormat","labelsSpec","entriesSpec","selections","length","channelDef","getConditionValue","v","conditionalDef","Math","max","reducer","reduce","fieldDef","map","name","store","join"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\node_modules\\vega-lite\\src\\compile\\legend\\encode.ts"],"sourcesContent":["import {ColorValueRef, EncodeEntry, Gradient, LegendEncode, LegendType, SignalRef, SymbolEncodeEntry} from 'vega';\nimport {array, isArray, stringValue} from 'vega-util';\nimport {COLOR, NonPositionScaleChannel, OPACITY} from '../../channel';\nimport {\n  Conditional,\n  DatumDef,\n  hasConditionalValueDef,\n  isFieldDef,\n  isValueDef,\n  TypedFieldDef,\n  Value,\n  ValueDef\n} from '../../channeldef';\nimport {Encoding} from '../../encoding';\nimport {FILL_STROKE_CONFIG} from '../../mark';\nimport {getFirstDefined, hasProperty, isEmpty, varName} from '../../util';\nimport {applyMarkConfig, signalOrValueRef} from '../common';\nimport {formatCustomType, isCustomFormatType} from '../format';\nimport * as mixins from '../mark/encode';\nimport {STORE} from '../selection';\nimport {UnitModel} from '../unit';\nimport {LegendComponent} from './component';\n\nexport interface LegendEncodeParams {\n  fieldOrDatumDef: TypedFieldDef<string> | DatumDef;\n  model: UnitModel;\n  channel: NonPositionScaleChannel;\n  legendCmpt: LegendComponent;\n  legendType: LegendType;\n}\n\nexport const legendEncodeRules: {\n  [part in keyof LegendEncode]?: (spec: EncodeEntry, params: LegendEncodeParams) => EncodeEntry;\n} = {\n  symbols,\n  gradient,\n  labels,\n  entries\n};\n\nexport function symbols(\n  symbolsSpec: any,\n  {fieldOrDatumDef, model, channel, legendCmpt, legendType}: LegendEncodeParams\n): SymbolEncodeEntry {\n  if (legendType !== 'symbol') {\n    return undefined;\n  }\n\n  const {markDef, encoding, config, mark} = model;\n  const filled = markDef.filled && mark !== 'trail';\n\n  let out = {\n    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),\n    ...mixins.color(model, {filled})\n  } as SymbolEncodeEntry; // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  const symbolOpacity = legendCmpt.get('symbolOpacity') ?? config.legend.symbolOpacity;\n  const symbolFillColor = legendCmpt.get('symbolFillColor') ?? config.legend.symbolFillColor;\n  const symbolStrokeColor = legendCmpt.get('symbolStrokeColor') ?? config.legend.symbolStrokeColor;\n\n  const opacity = symbolOpacity === undefined ? (getMaxValue(encoding.opacity) ?? markDef.opacity) : undefined;\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || (filled && channel === COLOR)) {\n      delete out.fill;\n    } else if (hasProperty(out.fill, 'field')) {\n      // For others, set fill to some opaque value (or nothing if a color is already set)\n      if (symbolFillColor) {\n        delete out.fill;\n      } else {\n        out.fill = signalOrValueRef(config.legend.symbolBaseFillColor ?? 'black');\n        out.fillOpacity = signalOrValueRef(opacity ?? 1);\n      }\n    } else if (isArray(out.fill)) {\n      const fill = getFirstConditionValue(encoding.fill ?? encoding.color) ?? markDef.fill ?? (filled && markDef.color);\n      if (fill) {\n        out.fill = signalOrValueRef(fill) as ColorValueRef;\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || (!filled && channel === COLOR)) {\n      delete out.stroke;\n    } else if (hasProperty(out.stroke, 'field') || symbolStrokeColor) {\n      // For others, remove stroke field\n      delete out.stroke;\n    } else if (isArray(out.stroke)) {\n      const stroke = getFirstDefined<string | Gradient | SignalRef>(\n        getFirstConditionValue<string | Gradient>(encoding.stroke || encoding.color),\n        markDef.stroke,\n        filled ? markDef.color : undefined\n      );\n      if (stroke) {\n        out.stroke = {value: stroke} as ColorValueRef;\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n\n    if (condition) {\n      out.opacity = [\n        {test: condition, ...signalOrValueRef(opacity ?? 1)},\n        signalOrValueRef(config.legend.unselectedOpacity)\n      ];\n    } else if (opacity) {\n      out.opacity = signalOrValueRef(opacity);\n    }\n  }\n\n  out = {...out, ...symbolsSpec};\n\n  return isEmpty(out) ? undefined : out;\n}\n\nexport function gradient(gradientSpec: any, {model, legendType, legendCmpt}: LegendEncodeParams) {\n  if (legendType !== 'gradient') {\n    return undefined;\n  }\n\n  const {config, markDef, encoding} = model;\n\n  let out: SymbolEncodeEntry = {};\n\n  const gradientOpacity = legendCmpt.get('gradientOpacity') ?? config.legend.gradientOpacity;\n  const opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = signalOrValueRef(opacity);\n  }\n\n  out = {...out, ...gradientSpec};\n  return isEmpty(out) ? undefined : out;\n}\n\nexport function labels(specifiedlabelsSpec: any, {fieldOrDatumDef, model, channel, legendCmpt}: LegendEncodeParams) {\n  const legend = model.legend(channel) || {};\n  const config = model.config;\n\n  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n  const opacity = condition ? [{test: condition, value: 1}, {value: config.legend.unselectedOpacity}] : undefined;\n\n  const {format, formatType} = legend;\n\n  let text = undefined;\n\n  if (isCustomFormatType(formatType)) {\n    text = formatCustomType({\n      fieldOrDatumDef,\n      field: 'datum.value',\n      format,\n      formatType,\n      config\n    });\n  } else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (fieldOrDatumDef.type === 'quantitative' && config.numberFormatType) {\n      text = formatCustomType({\n        fieldOrDatumDef,\n        field: 'datum.value',\n        format: config.numberFormat,\n        formatType: config.numberFormatType,\n        config\n      });\n    } else if (\n      fieldOrDatumDef.type === 'temporal' &&\n      config.timeFormatType &&\n      isFieldDef(fieldOrDatumDef) &&\n      fieldOrDatumDef.timeUnit === undefined\n    ) {\n      text = formatCustomType({\n        fieldOrDatumDef,\n        field: 'datum.value',\n        format: config.timeFormat,\n        formatType: config.timeFormatType,\n        config\n      });\n    }\n  }\n\n  const labelsSpec = {\n    ...(opacity ? {opacity} : {}),\n    ...(text ? {text} : {}),\n    ...specifiedlabelsSpec\n  };\n\n  return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\n\nexport function entries(entriesSpec: any, {legendCmpt}: LegendEncodeParams) {\n  const selections = legendCmpt.get('selections');\n  return selections?.length ? {...entriesSpec, fill: {value: 'transparent'}} : entriesSpec;\n}\n\nfunction getMaxValue(channelDef: Encoding<string>['opacity']) {\n  return getConditionValue<number>(channelDef, (v: number, conditionalDef) => Math.max(v, conditionalDef.value as any));\n}\n\nexport function getFirstConditionValue<V extends Value | Gradient>(\n  channelDef: Encoding<string>['fill' | 'stroke' | 'shape']\n): V {\n  return getConditionValue<V>(channelDef, (v: V, conditionalDef: Conditional<ValueDef<V>>) => {\n    return getFirstDefined<V>(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue<V extends Value | Gradient>(\n  channelDef: Encoding<string>['fill' | 'stroke' | 'shape' | 'opacity'],\n  reducer: (val: V, conditionalDef: Conditional<ValueDef<V>>) => V\n): V {\n  if (hasConditionalValueDef(channelDef)) {\n    return array(channelDef.condition).reduce(reducer, channelDef.value as any);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value as any;\n  }\n  return undefined;\n}\n\nfunction selectedCondition(model: UnitModel, legendCmpt: LegendComponent, fieldDef: TypedFieldDef<string>) {\n  const selections = legendCmpt.get('selections');\n  if (!selections?.length) return undefined;\n\n  const field = stringValue(fieldDef.field);\n  return selections\n    .map(name => {\n      const store = stringValue(varName(name) + STORE);\n      return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n    })\n    .join(' || ');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}