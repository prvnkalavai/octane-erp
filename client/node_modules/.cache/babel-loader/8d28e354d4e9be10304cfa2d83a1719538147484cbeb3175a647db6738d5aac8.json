{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { TUPLE, isTimerSelection, unitName } from '.';\nimport { SELECTION_ID } from '../../selection';\nimport { vals } from '../../util';\nimport { BRUSH } from './interval';\nimport { TUPLE_FIELDS } from './project';\nimport { TIME } from '../../channel';\nexport const CURR = '_curr';\nexport const ANIM_VALUE = 'anim_value';\nexport const ANIM_CLOCK = 'anim_clock';\nexport const EASED_ANIM_CLOCK = 'eased_anim_clock';\nexport const MIN_EXTENT = 'min_extent';\nexport const MAX_RANGE_EXTENT = 'max_range_extent';\nexport const LAST_TICK = 'last_tick_at';\nexport const IS_PLAYING = 'is_playing';\nexport const THROTTLE = 1 / 60 * 1000; // 60 FPS\nconst animationSignals = (selectionName, scaleName) => {\n  return [\n  // timer signals\n  {\n    name: EASED_ANIM_CLOCK,\n    // update: 'easeLinear(anim_clock / max_range_extent) * max_range_extent'\n    update: ANIM_CLOCK // TODO: replace with above once easing functions are implemented in vega-functions\n  },\n  // scale signals\n  // TODO(jzong): uncomment commented signals below when implementing interpolation\n  {\n    name: `${selectionName}_domain`,\n    init: `domain('${scaleName}')`\n  }, {\n    name: MIN_EXTENT,\n    init: `extent(${selectionName}_domain)[0]`\n  },\n  // {name: 'max_extent', init: `extent(${selectionName}_domain)[1]`},\n  {\n    name: MAX_RANGE_EXTENT,\n    init: `extent(range('${scaleName}'))[1]`\n  },\n  // {name: 't_index', update: `indexof(${selectionName}_domain, anim_value)`},\n  {\n    name: ANIM_VALUE,\n    update: `invert('${scaleName}', ${EASED_ANIM_CLOCK})`\n  }];\n};\nconst point = {\n  defined: selCmpt => selCmpt.type === 'point',\n  topLevelSignals: (model, selCmpt, signals) => {\n    if (isTimerSelection(selCmpt)) {\n      signals = signals.concat([{\n        name: ANIM_CLOCK,\n        init: '0',\n        on: [{\n          events: {\n            type: 'timer',\n            throttle: THROTTLE\n          },\n          update: `${IS_PLAYING} ? (${ANIM_CLOCK} + (now() - ${LAST_TICK}) > ${MAX_RANGE_EXTENT} ? 0 : ${ANIM_CLOCK} + (now() - ${LAST_TICK})) : ${ANIM_CLOCK}`\n        }]\n      }, {\n        name: LAST_TICK,\n        init: 'now()',\n        on: [{\n          events: [{\n            signal: ANIM_CLOCK\n          }, {\n            signal: IS_PLAYING\n          }],\n          update: 'now()'\n        }]\n      }, {\n        name: IS_PLAYING,\n        init: 'true'\n      }]);\n    }\n    return signals;\n  },\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const project = selCmpt.project;\n    const datum = '(item().isVoronoi ? datum.datum : datum)';\n    // Only add a discrete selection to the store if a datum is present _and_\n    // the interaction isn't occurring on a group mark. This guards against\n    // polluting interactive state with invalid values in faceted displays\n    // as the group marks are also data-driven. We force the update to account\n    // for constant null states but varying toggles (e.g., shift-click in\n    // whitespace followed by a click in whitespace; the store should only\n    // be cleared on the second click).\n    const brushes = vals(model.component.selection ?? {}).reduce((acc, cmpt) => {\n      return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n    }, []).map(b => `indexof(item().mark.name, '${b}') < 0`).join(' && ');\n    const test = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${brushes ? ` && ${brushes}` : ''}`;\n    let update = `unit: ${unitName(model)}, `;\n    if (selCmpt.project.hasSelectionId) {\n      update += `${SELECTION_ID}: ${datum}[${stringValue(SELECTION_ID)}]`;\n    } else if (isTimerSelection(selCmpt)) {\n      update += `fields: ${fieldsSg}, values: [${ANIM_VALUE} ? ${ANIM_VALUE} : ${MIN_EXTENT}]`;\n    } else {\n      const values = project.items.map(p => {\n        const fieldDef = model.fieldDef(p.channel);\n        // Binned fields should capture extents, for a range test against the raw field.\n        return fieldDef?.bin ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` + `${datum}[${stringValue(model.vgField(p.channel, {\n          binSuffix: 'end'\n        }))}]]` : `${datum}[${stringValue(p.field)}]`;\n      }).join(', ');\n      update += `fields: ${fieldsSg}, values: [${values}]`;\n    }\n    if (isTimerSelection(selCmpt)) {\n      // timer event: selection is for animation\n      return signals.concat(animationSignals(selCmpt.name, model.scaleName(TIME)), [{\n        name: name + TUPLE,\n        on: [{\n          events: [{\n            signal: EASED_ANIM_CLOCK\n          }, {\n            signal: ANIM_VALUE\n          }],\n          update: `{${update}}`,\n          force: true\n        }]\n      }]);\n    } else {\n      const events = selCmpt.events;\n      return signals.concat([{\n        name: name + TUPLE,\n        on: events ? [{\n          events,\n          update: `${test} ? {${update}} : null`,\n          force: true\n        }] : []\n      }]);\n    }\n  }\n};\nexport default point;","map":{"version":3,"names":["stringValue","TUPLE","isTimerSelection","unitName","SELECTION_ID","vals","BRUSH","TUPLE_FIELDS","TIME","CURR","ANIM_VALUE","ANIM_CLOCK","EASED_ANIM_CLOCK","MIN_EXTENT","MAX_RANGE_EXTENT","LAST_TICK","IS_PLAYING","THROTTLE","animationSignals","selectionName","scaleName","name","update","init","point","defined","selCmpt","type","topLevelSignals","model","signals","concat","on","events","throttle","signal","fieldsSg","project","datum","brushes","component","selection","reduce","acc","cmpt","map","b","join","test","hasSelectionId","values","items","p","fieldDef","channel","bin","vgField","binSuffix","field","force"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\client\\node_modules\\vega-lite\\src\\compile\\selection\\point.ts"],"sourcesContent":["import {Signal, Stream} from 'vega';\nimport {stringValue} from 'vega-util';\nimport {SelectionCompiler, TUPLE, isTimerSelection, unitName} from '.';\nimport {SELECTION_ID} from '../../selection';\nimport {vals} from '../../util';\nimport {BRUSH} from './interval';\nimport {TUPLE_FIELDS} from './project';\nimport {TIME} from '../../channel';\n\nexport const CURR = '_curr';\nexport const ANIM_VALUE = 'anim_value';\nexport const ANIM_CLOCK = 'anim_clock';\nexport const EASED_ANIM_CLOCK = 'eased_anim_clock';\nexport const MIN_EXTENT = 'min_extent';\nexport const MAX_RANGE_EXTENT = 'max_range_extent';\nexport const LAST_TICK = 'last_tick_at';\nexport const IS_PLAYING = 'is_playing';\nexport const THROTTLE = (1 / 60) * 1000; // 60 FPS\n\nconst animationSignals = (selectionName: string, scaleName: string): Signal[] => {\n  return [\n    // timer signals\n    {\n      name: EASED_ANIM_CLOCK,\n      // update: 'easeLinear(anim_clock / max_range_extent) * max_range_extent'\n      update: ANIM_CLOCK // TODO: replace with above once easing functions are implemented in vega-functions\n    },\n\n    // scale signals\n    // TODO(jzong): uncomment commented signals below when implementing interpolation\n    {name: `${selectionName}_domain`, init: `domain('${scaleName}')`},\n    {name: MIN_EXTENT, init: `extent(${selectionName}_domain)[0]`},\n    // {name: 'max_extent', init: `extent(${selectionName}_domain)[1]`},\n    {name: MAX_RANGE_EXTENT, init: `extent(range('${scaleName}'))[1]`},\n    // {name: 't_index', update: `indexof(${selectionName}_domain, anim_value)`},\n    {name: ANIM_VALUE, update: `invert('${scaleName}', ${EASED_ANIM_CLOCK})`}\n  ];\n};\n\nconst point: SelectionCompiler<'point'> = {\n  defined: selCmpt => selCmpt.type === 'point',\n\n  topLevelSignals: (model, selCmpt, signals) => {\n    if (isTimerSelection(selCmpt)) {\n      signals = signals.concat([\n        {\n          name: ANIM_CLOCK,\n          init: '0',\n          on: [\n            {\n              events: {type: 'timer', throttle: THROTTLE},\n              update: `${IS_PLAYING} ? (${ANIM_CLOCK} + (now() - ${LAST_TICK}) > ${MAX_RANGE_EXTENT} ? 0 : ${ANIM_CLOCK} + (now() - ${LAST_TICK})) : ${ANIM_CLOCK}`\n            }\n          ]\n        },\n        {\n          name: LAST_TICK,\n          init: 'now()',\n          on: [{events: [{signal: ANIM_CLOCK}, {signal: IS_PLAYING}], update: 'now()'}]\n        },\n        {\n          name: IS_PLAYING,\n          init: 'true'\n        }\n      ]);\n    }\n\n    return signals;\n  },\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const project = selCmpt.project;\n    const datum = '(item().isVoronoi ? datum.datum : datum)';\n\n    // Only add a discrete selection to the store if a datum is present _and_\n    // the interaction isn't occurring on a group mark. This guards against\n    // polluting interactive state with invalid values in faceted displays\n    // as the group marks are also data-driven. We force the update to account\n    // for constant null states but varying toggles (e.g., shift-click in\n    // whitespace followed by a click in whitespace; the store should only\n    // be cleared on the second click).\n    const brushes = vals(model.component.selection ?? {})\n      .reduce((acc, cmpt) => {\n        return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n      }, [])\n      .map(b => `indexof(item().mark.name, '${b}') < 0`)\n      .join(' && ');\n\n    const test = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${\n      brushes ? ` && ${brushes}` : ''\n    }`;\n\n    let update = `unit: ${unitName(model)}, `;\n\n    if (selCmpt.project.hasSelectionId) {\n      update += `${SELECTION_ID}: ${datum}[${stringValue(SELECTION_ID)}]`;\n    } else if (isTimerSelection(selCmpt)) {\n      update += `fields: ${fieldsSg}, values: [${ANIM_VALUE} ? ${ANIM_VALUE} : ${MIN_EXTENT}]`;\n    } else {\n      const values = project.items\n        .map(p => {\n          const fieldDef = model.fieldDef(p.channel);\n          // Binned fields should capture extents, for a range test against the raw field.\n          return fieldDef?.bin\n            ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` +\n                `${datum}[${stringValue(model.vgField(p.channel, {binSuffix: 'end'}))}]]`\n            : `${datum}[${stringValue(p.field)}]`;\n        })\n        .join(', ');\n\n      update += `fields: ${fieldsSg}, values: [${values}]`;\n    }\n\n    if (isTimerSelection(selCmpt)) {\n      // timer event: selection is for animation\n      return signals.concat(animationSignals(selCmpt.name, model.scaleName(TIME)), [\n        {\n          name: name + TUPLE,\n          on: [\n            {\n              events: [{signal: EASED_ANIM_CLOCK}, {signal: ANIM_VALUE}],\n              update: `{${update}}`,\n              force: true\n            }\n          ]\n        }\n      ]);\n    } else {\n      const events: Stream[] = selCmpt.events;\n      return signals.concat([\n        {\n          name: name + TUPLE,\n          on: events\n            ? [\n                {\n                  events,\n                  update: `${test} ? {${update}} : null`,\n                  force: true\n                }\n              ]\n            : []\n        }\n      ]);\n    }\n  }\n};\n\nexport default point;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}