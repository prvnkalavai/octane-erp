{"ast":null,"code":"import { parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers, isTimerSelection } from '.';\nimport { dateTimeToExpr, isDateTime, dateTimeToTimestamp } from '../../datetime';\nimport { hasContinuousDomain } from '../../scale';\nimport { SELECTION_ID } from '../../selection';\nimport { keys, replacePathInField, stringify, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from './parse';\nimport { CURR } from './point';\nimport { DataSourceType } from '../../data';\nexport function assembleProjection(proj) {\n  const {\n    signals,\n    hasLegend,\n    index,\n    ...rest\n  } = proj;\n  rest.field = replacePathInField(rest.field);\n  return rest;\n}\nexport function assembleInit(init, isExpr = true, wrap = identity) {\n  if (isArray(init)) {\n    const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n    return isExpr ? `[${assembled.join(', ')}]` : assembled;\n  } else if (isDateTime(init)) {\n    if (isExpr) {\n      return wrap(dateTimeToExpr(init));\n    } else {\n      return wrap(dateTimeToTimestamp(init));\n    }\n  }\n  return isExpr ? wrap(stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const name = selCmpt.name;\n    let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`}`;\n    for (const c of selectionCompilers) {\n      if (!c.defined(selCmpt)) continue;\n      if (c.signals) signals = c.signals(model, selCmpt, signals);\n      if (c.modifyExpr) modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n    }\n    signals.push({\n      name: name + MODIFY,\n      on: [{\n        events: {\n          signal: selCmpt.name + TUPLE\n        },\n        update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n      }]\n    });\n  }\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    const name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [{\n        events: parseSelector('pointermove', 'scope'),\n        update: `isTuple(facet) ? facet : group(${name}).datum`\n      }]\n    });\n  }\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n  let hasSelections = false;\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const name = selCmpt.name;\n    const store = stringValue(name + STORE);\n    const hasSg = signals.filter(s => s.name === name);\n    if (hasSg.length === 0) {\n      const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n      const isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n      signals.push({\n        name: selCmpt.name,\n        update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isPoint}`\n      });\n    }\n    hasSelections = true;\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.topLevelSignals) {\n        signals = c.topLevelSignals(model, selCmpt, signals);\n      }\n    }\n  }\n  if (hasSelections) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{\n          events: 'pointermove',\n          update: 'isTuple(group()) ? group() : unit'\n        }]\n      });\n    }\n  }\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n  const selectionData = [];\n  const animationData = [];\n  const unit = unitName(model, {\n    escape: false\n  });\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const store = {\n      name: selCmpt.name + STORE\n    };\n    if (selCmpt.project.hasSelectionId) {\n      store.transform = [{\n        type: 'collect',\n        sort: {\n          field: SELECTION_ID\n        }\n      }];\n    }\n    if (selCmpt.init) {\n      const fields = selCmpt.project.items.map(assembleProjection);\n      store.values = selCmpt.project.hasSelectionId ? selCmpt.init.map(i => ({\n        unit,\n        [SELECTION_ID]: assembleInit(i, false)[0]\n      })) : selCmpt.init.map(i => ({\n        unit,\n        fields,\n        values: assembleInit(i, false)\n      }));\n    }\n    const contains = [...selectionData, ...data].filter(d => d.name === selCmpt.name + STORE);\n    if (!contains.length) {\n      selectionData.push(store);\n    }\n    if (isTimerSelection(selCmpt) && data.length) {\n      // TODO(jzong): eventually uncomment this stuff when we want to support multi-view\n      // const sourceName =\n      //   model.parent && model.parent.type !== 'unit' // facet, layer, or concat\n      //     ? model.parent.lookupDataSource(model.parent.getDataName(DataSourceType.Main))\n      //     : model.lookupDataSource(model.getDataName(DataSourceType.Main));\n      const sourceName = model.lookupDataSource(model.getDataName(DataSourceType.Main));\n      const sourceData = data.find(d => d.name === sourceName);\n      // find the filter transform for the current selection\n      const sourceDataFilter = sourceData.transform.find(t => t.type === 'filter' && t.expr.includes('vlSelectionTest'));\n      if (sourceDataFilter) {\n        // remove it from the original dataset\n        sourceData.transform = sourceData.transform.filter(t => t !== sourceDataFilter);\n        // create dataset to hold current animation frame\n        const currentFrame = {\n          name: sourceData.name + CURR,\n          source: sourceData.name,\n          transform: [sourceDataFilter] // add the selection filter to the animation dataset\n        };\n        animationData.push(currentFrame);\n      }\n    }\n  }\n  return selectionData.concat(data, animationData);\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.marks) {\n        marks = c.marks(model, selCmpt, marks);\n      }\n    }\n  }\n  return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n  for (const child of model.children) {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  }\n  return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent, scaleCmpt, domain) {\n  const parsedExtent = parseSelectionExtent(model, extent.param, extent);\n  return {\n    signal: hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1] ? `isValid(${parsedExtent}) && reverse(${parsedExtent})` : parsedExtent\n  };\n}\nfunction cleanupEmptyOnArray(signals) {\n  return signals.map(s => {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}","map":{"version":3,"names":["parseSelector","identity","isArray","stringValue","MODIFY","STORE","unitName","VL_SELECTION_RESOLVE","TUPLE","selectionCompilers","isTimerSelection","dateTimeToExpr","isDateTime","dateTimeToTimestamp","hasContinuousDomain","SELECTION_ID","keys","replacePathInField","stringify","vals","isUnitModel","parseSelectionExtent","CURR","DataSourceType","assembleProjection","proj","signals","hasLegend","index","rest","field","assembleInit","init","isExpr","wrap","assembled","map","v","join","assembleUnitSelectionSignals","model","selCmpt","component","selection","name","modifyExpr","resolve","c","defined","push","on","events","signal","update","cleanupEmptyOnArray","assembleFacetSignals","length","getName","unshift","value","assembleTopLevelSignals","hasSelections","store","hasSg","filter","s","isPoint","type","topLevelSignals","hasUnit","assembleUnitSelectionData","data","selectionData","animationData","unit","escape","project","hasSelectionId","transform","sort","fields","items","values","i","contains","d","sourceName","lookupDataSource","getDataName","Main","sourceData","find","sourceDataFilter","t","expr","includes","currentFrame","source","concat","assembleUnitSelectionMarks","marks","assembleLayerSelectionMarks","child","children","assembleSelectionScaleDomain","extent","scaleCmpt","domain","parsedExtent","param","get"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\node_modules\\vega-lite\\src\\compile\\selection\\assemble.ts"],"sourcesContent":["import {Signal, SignalRef} from 'vega';\nimport {parseSelector} from 'vega-event-selector';\nimport {identity, isArray, stringValue} from 'vega-util';\nimport {MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers, isTimerSelection} from '.';\nimport {dateTimeToExpr, isDateTime, dateTimeToTimestamp} from '../../datetime';\nimport {hasContinuousDomain} from '../../scale';\nimport {SelectionInit, SelectionInitInterval, ParameterExtent, SELECTION_ID} from '../../selection';\nimport {keys, replacePathInField, stringify, vals} from '../../util';\nimport {VgData, VgDomain} from '../../vega.schema';\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {isUnitModel, Model} from '../model';\nimport {ScaleComponent} from '../scale/component';\nimport {UnitModel} from '../unit';\nimport {parseSelectionExtent} from './parse';\nimport {SelectionProjection} from './project';\nimport {CURR} from './point';\nimport {DataSourceType} from '../../data';\n\nexport function assembleProjection(proj: SelectionProjection) {\n  const {signals, hasLegend, index, ...rest} = proj;\n  rest.field = replacePathInField(rest.field);\n  return rest;\n}\n\nexport function assembleInit(\n  init: readonly (SelectionInit | readonly SelectionInit[] | SelectionInitInterval)[] | SelectionInit,\n  isExpr = true,\n  wrap: (str: string | number) => string | number = identity\n): any {\n  if (isArray(init)) {\n    const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n    return isExpr ? `[${assembled.join(', ')}]` : assembled;\n  } else if (isDateTime(init)) {\n    if (isExpr) {\n      return wrap(dateTimeToExpr(init));\n    } else {\n      return wrap(dateTimeToTimestamp(init));\n    }\n  }\n  return isExpr ? wrap(stringify(init)) : init;\n}\n\nexport function assembleUnitSelectionSignals(model: UnitModel, signals: Signal[]) {\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const name = selCmpt.name;\n    let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`}`;\n\n    for (const c of selectionCompilers) {\n      if (!c.defined(selCmpt)) continue;\n      if (c.signals) signals = c.signals(model, selCmpt, signals);\n      if (c.modifyExpr) modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n    }\n\n    signals.push({\n      name: name + MODIFY,\n      on: [\n        {\n          events: {signal: selCmpt.name + TUPLE},\n          update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n        }\n      ]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleFacetSignals(model: FacetModel, signals: Signal[]) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    const name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [\n        {\n          events: parseSelector('pointermove', 'scope'),\n          update: `isTuple(facet) ? facet : group(${name}).datum`\n        }\n      ]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleTopLevelSignals(model: UnitModel, signals: Signal[]) {\n  let hasSelections = false;\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const name = selCmpt.name;\n    const store = stringValue(name + STORE);\n    const hasSg = signals.filter(s => s.name === name);\n    if (hasSg.length === 0) {\n      const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n      const isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n      signals.push({\n        name: selCmpt.name,\n        update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isPoint}`\n      });\n    }\n    hasSelections = true;\n\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.topLevelSignals) {\n        signals = c.topLevelSignals(model, selCmpt, signals);\n      }\n    }\n  }\n\n  if (hasSelections) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{events: 'pointermove', update: 'isTuple(group()) ? group() : unit'}]\n      });\n    }\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\n\nexport function assembleUnitSelectionData(model: UnitModel, data: readonly VgData[]): VgData[] {\n  const selectionData = [];\n  const animationData = [];\n  const unit = unitName(model, {escape: false});\n\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    const store: VgData = {name: selCmpt.name + STORE};\n\n    if (selCmpt.project.hasSelectionId) {\n      store.transform = [{type: 'collect', sort: {field: SELECTION_ID}}];\n    }\n\n    if (selCmpt.init) {\n      const fields = selCmpt.project.items.map(assembleProjection);\n\n      store.values = selCmpt.project.hasSelectionId\n        ? selCmpt.init.map(i => ({unit, [SELECTION_ID]: assembleInit(i, false)[0]}))\n        : selCmpt.init.map(i => ({unit, fields, values: assembleInit(i, false)}));\n    }\n\n    const contains = [...selectionData, ...data].filter(d => d.name === selCmpt.name + STORE);\n    if (!contains.length) {\n      selectionData.push(store);\n    }\n\n    if (isTimerSelection(selCmpt) && data.length) {\n      // TODO(jzong): eventually uncomment this stuff when we want to support multi-view\n      // const sourceName =\n      //   model.parent && model.parent.type !== 'unit' // facet, layer, or concat\n      //     ? model.parent.lookupDataSource(model.parent.getDataName(DataSourceType.Main))\n      //     : model.lookupDataSource(model.getDataName(DataSourceType.Main));\n      const sourceName = model.lookupDataSource(model.getDataName(DataSourceType.Main));\n      const sourceData = data.find(d => d.name === sourceName);\n\n      // find the filter transform for the current selection\n      const sourceDataFilter = sourceData.transform.find(\n        t => t.type === 'filter' && t.expr.includes('vlSelectionTest')\n      );\n\n      if (sourceDataFilter) {\n        // remove it from the original dataset\n        sourceData.transform = sourceData.transform.filter(t => t !== sourceDataFilter);\n\n        // create dataset to hold current animation frame\n        const currentFrame: VgData = {\n          name: sourceData.name + CURR,\n          source: sourceData.name,\n          transform: [sourceDataFilter] // add the selection filter to the animation dataset\n        };\n\n        animationData.push(currentFrame);\n      }\n    }\n  }\n\n  return selectionData.concat(data, animationData);\n}\n\nexport function assembleUnitSelectionMarks(model: UnitModel, marks: any[]): any[] {\n  for (const selCmpt of vals(model.component.selection ?? {})) {\n    for (const c of selectionCompilers) {\n      if (c.defined(selCmpt) && c.marks) {\n        marks = c.marks(model, selCmpt, marks);\n      }\n    }\n  }\n\n  return marks;\n}\n\nexport function assembleLayerSelectionMarks(model: LayerModel, marks: any[]): any[] {\n  for (const child of model.children) {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  }\n\n  return marks;\n}\n\nexport function assembleSelectionScaleDomain(\n  model: Model,\n  extent: ParameterExtent,\n  scaleCmpt: ScaleComponent,\n  domain: VgDomain\n): SignalRef {\n  const parsedExtent = parseSelectionExtent(model, extent.param, extent);\n\n  return {\n    signal:\n      hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1]\n        ? `isValid(${parsedExtent}) && reverse(${parsedExtent})`\n        : parsedExtent\n  };\n}\n\nfunction cleanupEmptyOnArray(signals: Signal[]) {\n  return signals.map(s => {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}\n"],"mappings":"AACA,SAAQA,aAAa,QAAO,qBAAqB;AACjD,SAAQC,QAAQ,EAAEC,OAAO,EAAEC,WAAW,QAAO,WAAW;AACxD,SAAQC,MAAM,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,oBAAoB,EAAEC,KAAK,EAAEC,kBAAkB,EAAEC,gBAAgB,QAAO,GAAG;AAC5G,SAAQC,cAAc,EAAEC,UAAU,EAAEC,mBAAmB,QAAO,gBAAgB;AAC9E,SAAQC,mBAAmB,QAAO,aAAa;AAC/C,SAA+DC,YAAY,QAAO,iBAAiB;AACnG,SAAQC,IAAI,EAAEC,kBAAkB,EAAEC,SAAS,EAAEC,IAAI,QAAO,YAAY;AAIpE,SAAQC,WAAW,QAAc,UAAU;AAG3C,SAAQC,oBAAoB,QAAO,SAAS;AAE5C,SAAQC,IAAI,QAAO,SAAS;AAC5B,SAAQC,cAAc,QAAO,YAAY;AAEzC,OAAM,SAAUC,kBAAkBA,CAACC,IAAyB;EAC1D,MAAM;IAACC,OAAO;IAAEC,SAAS;IAAEC,KAAK;IAAE,GAAGC;EAAI,CAAC,GAAGJ,IAAI;EACjDI,IAAI,CAACC,KAAK,GAAGb,kBAAkB,CAACY,IAAI,CAACC,KAAK,CAAC;EAC3C,OAAOD,IAAI;AACb;AAEA,OAAM,SAAUE,YAAYA,CAC1BC,IAAmG,EACnGC,MAAM,GAAG,IAAI,EACbC,IAAA,GAAkDjC,QAAQ;EAE1D,IAAIC,OAAO,CAAC8B,IAAI,CAAC,EAAE;IACjB,MAAMG,SAAS,GAAGH,IAAI,CAACI,GAAG,CAACC,CAAC,IAAIN,YAAY,CAACM,CAAC,EAAEJ,MAAM,EAAEC,IAAI,CAAC,CAAC;IAC9D,OAAOD,MAAM,GAAG,IAAIE,SAAS,CAACG,IAAI,CAAC,IAAI,CAAC,GAAG,GAAGH,SAAS;EACzD,CAAC,MAAM,IAAIvB,UAAU,CAACoB,IAAI,CAAC,EAAE;IAC3B,IAAIC,MAAM,EAAE;MACV,OAAOC,IAAI,CAACvB,cAAc,CAACqB,IAAI,CAAC,CAAC;IACnC,CAAC,MAAM;MACL,OAAOE,IAAI,CAACrB,mBAAmB,CAACmB,IAAI,CAAC,CAAC;IACxC;EACF;EACA,OAAOC,MAAM,GAAGC,IAAI,CAAChB,SAAS,CAACc,IAAI,CAAC,CAAC,GAAGA,IAAI;AAC9C;AAEA,OAAM,SAAUO,4BAA4BA,CAACC,KAAgB,EAAEd,OAAiB;EAC9E,KAAK,MAAMe,OAAO,IAAItB,IAAI,CAACqB,KAAK,CAACE,SAAS,CAACC,SAAS,IAAI,EAAE,CAAC,EAAE;IAC3D,MAAMC,IAAI,GAAGH,OAAO,CAACG,IAAI;IACzB,IAAIC,UAAU,GAAG,GAAGD,IAAI,GAAGpC,KAAK,KAAKiC,OAAO,CAACK,OAAO,KAAK,QAAQ,GAAG,MAAM,GAAG,UAAUxC,QAAQ,CAACkC,KAAK,CAAC,GAAG,EAAE;IAE3G,KAAK,MAAMO,CAAC,IAAItC,kBAAkB,EAAE;MAClC,IAAI,CAACsC,CAAC,CAACC,OAAO,CAACP,OAAO,CAAC,EAAE;MACzB,IAAIM,CAAC,CAACrB,OAAO,EAAEA,OAAO,GAAGqB,CAAC,CAACrB,OAAO,CAACc,KAAK,EAAEC,OAAO,EAAEf,OAAO,CAAC;MAC3D,IAAIqB,CAAC,CAACF,UAAU,EAAEA,UAAU,GAAGE,CAAC,CAACF,UAAU,CAACL,KAAK,EAAEC,OAAO,EAAEI,UAAU,CAAC;IACzE;IAEAnB,OAAO,CAACuB,IAAI,CAAC;MACXL,IAAI,EAAEA,IAAI,GAAGxC,MAAM;MACnB8C,EAAE,EAAE,CACF;QACEC,MAAM,EAAE;UAACC,MAAM,EAAEX,OAAO,CAACG,IAAI,GAAGpC;QAAK,CAAC;QACtC6C,MAAM,EAAE,UAAUlD,WAAW,CAACsC,OAAO,CAACG,IAAI,GAAGvC,KAAK,CAAC,KAAKwC,UAAU;OACnE;KAEJ,CAAC;EACJ;EAEA,OAAOS,mBAAmB,CAAC5B,OAAO,CAAC;AACrC;AAEA,OAAM,SAAU6B,oBAAoBA,CAACf,KAAiB,EAAEd,OAAiB;EACvE,IAAIc,KAAK,CAACE,SAAS,CAACC,SAAS,IAAI3B,IAAI,CAACwB,KAAK,CAACE,SAAS,CAACC,SAAS,CAAC,CAACa,MAAM,EAAE;IACvE,MAAMZ,IAAI,GAAGzC,WAAW,CAACqC,KAAK,CAACiB,OAAO,CAAC,MAAM,CAAC,CAAC;IAC/C/B,OAAO,CAACgC,OAAO,CAAC;MACdd,IAAI,EAAE,OAAO;MACbe,KAAK,EAAE,EAAE;MACTT,EAAE,EAAE,CACF;QACEC,MAAM,EAAEnD,aAAa,CAAC,aAAa,EAAE,OAAO,CAAC;QAC7CqD,MAAM,EAAE,kCAAkCT,IAAI;OAC/C;KAEJ,CAAC;EACJ;EAEA,OAAOU,mBAAmB,CAAC5B,OAAO,CAAC;AACrC;AAEA,OAAM,SAAUkC,uBAAuBA,CAACpB,KAAgB,EAAEd,OAAiB;EACzE,IAAImC,aAAa,GAAG,KAAK;EACzB,KAAK,MAAMpB,OAAO,IAAItB,IAAI,CAACqB,KAAK,CAACE,SAAS,CAACC,SAAS,IAAI,EAAE,CAAC,EAAE;IAC3D,MAAMC,IAAI,GAAGH,OAAO,CAACG,IAAI;IACzB,MAAMkB,KAAK,GAAG3D,WAAW,CAACyC,IAAI,GAAGvC,KAAK,CAAC;IACvC,MAAM0D,KAAK,GAAGrC,OAAO,CAACsC,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACrB,IAAI,KAAKA,IAAI,CAAC;IAClD,IAAImB,KAAK,CAACP,MAAM,KAAK,CAAC,EAAE;MACtB,MAAMV,OAAO,GAAGL,OAAO,CAACK,OAAO,KAAK,QAAQ,GAAG,OAAO,GAAGL,OAAO,CAACK,OAAO;MACxE,MAAMoB,OAAO,GAAGzB,OAAO,CAAC0B,IAAI,KAAK,OAAO,GAAG,eAAe,GAAG,GAAG;MAChEzC,OAAO,CAACuB,IAAI,CAAC;QACXL,IAAI,EAAEH,OAAO,CAACG,IAAI;QAClBS,MAAM,EAAE,GAAG9C,oBAAoB,IAAIuD,KAAK,KAAK3D,WAAW,CAAC2C,OAAO,CAAC,GAAGoB,OAAO;OAC5E,CAAC;IACJ;IACAL,aAAa,GAAG,IAAI;IAEpB,KAAK,MAAMd,CAAC,IAAItC,kBAAkB,EAAE;MAClC,IAAIsC,CAAC,CAACC,OAAO,CAACP,OAAO,CAAC,IAAIM,CAAC,CAACqB,eAAe,EAAE;QAC3C1C,OAAO,GAAGqB,CAAC,CAACqB,eAAe,CAAC5B,KAAK,EAAEC,OAAO,EAAEf,OAAO,CAAC;MACtD;IACF;EACF;EAEA,IAAImC,aAAa,EAAE;IACjB,MAAMQ,OAAO,GAAG3C,OAAO,CAACsC,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACrB,IAAI,KAAK,MAAM,CAAC;IACtD,IAAIyB,OAAO,CAACb,MAAM,KAAK,CAAC,EAAE;MACxB9B,OAAO,CAACgC,OAAO,CAAC;QACdd,IAAI,EAAE,MAAM;QACZe,KAAK,EAAE,EAAE;QACTT,EAAE,EAAE,CAAC;UAACC,MAAM,EAAE,aAAa;UAAEE,MAAM,EAAE;QAAmC,CAAC;OAC1E,CAAC;IACJ;EACF;EAEA,OAAOC,mBAAmB,CAAC5B,OAAO,CAAC;AACrC;AAEA,OAAM,SAAU4C,yBAAyBA,CAAC9B,KAAgB,EAAE+B,IAAuB;EACjF,MAAMC,aAAa,GAAG,EAAE;EACxB,MAAMC,aAAa,GAAG,EAAE;EACxB,MAAMC,IAAI,GAAGpE,QAAQ,CAACkC,KAAK,EAAE;IAACmC,MAAM,EAAE;EAAK,CAAC,CAAC;EAE7C,KAAK,MAAMlC,OAAO,IAAItB,IAAI,CAACqB,KAAK,CAACE,SAAS,CAACC,SAAS,IAAI,EAAE,CAAC,EAAE;IAC3D,MAAMmB,KAAK,GAAW;MAAClB,IAAI,EAAEH,OAAO,CAACG,IAAI,GAAGvC;IAAK,CAAC;IAElD,IAAIoC,OAAO,CAACmC,OAAO,CAACC,cAAc,EAAE;MAClCf,KAAK,CAACgB,SAAS,GAAG,CAAC;QAACX,IAAI,EAAE,SAAS;QAAEY,IAAI,EAAE;UAACjD,KAAK,EAAEf;QAAY;MAAC,CAAC,CAAC;IACpE;IAEA,IAAI0B,OAAO,CAACT,IAAI,EAAE;MAChB,MAAMgD,MAAM,GAAGvC,OAAO,CAACmC,OAAO,CAACK,KAAK,CAAC7C,GAAG,CAACZ,kBAAkB,CAAC;MAE5DsC,KAAK,CAACoB,MAAM,GAAGzC,OAAO,CAACmC,OAAO,CAACC,cAAc,GACzCpC,OAAO,CAACT,IAAI,CAACI,GAAG,CAAC+C,CAAC,KAAK;QAACT,IAAI;QAAE,CAAC3D,YAAY,GAAGgB,YAAY,CAACoD,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;MAAC,CAAC,CAAC,CAAC,GAC1E1C,OAAO,CAACT,IAAI,CAACI,GAAG,CAAC+C,CAAC,KAAK;QAACT,IAAI;QAAEM,MAAM;QAAEE,MAAM,EAAEnD,YAAY,CAACoD,CAAC,EAAE,KAAK;MAAC,CAAC,CAAC,CAAC;IAC7E;IAEA,MAAMC,QAAQ,GAAG,CAAC,GAAGZ,aAAa,EAAE,GAAGD,IAAI,CAAC,CAACP,MAAM,CAACqB,CAAC,IAAIA,CAAC,CAACzC,IAAI,KAAKH,OAAO,CAACG,IAAI,GAAGvC,KAAK,CAAC;IACzF,IAAI,CAAC+E,QAAQ,CAAC5B,MAAM,EAAE;MACpBgB,aAAa,CAACvB,IAAI,CAACa,KAAK,CAAC;IAC3B;IAEA,IAAIpD,gBAAgB,CAAC+B,OAAO,CAAC,IAAI8B,IAAI,CAACf,MAAM,EAAE;MAC5C;MACA;MACA;MACA;MACA;MACA,MAAM8B,UAAU,GAAG9C,KAAK,CAAC+C,gBAAgB,CAAC/C,KAAK,CAACgD,WAAW,CAACjE,cAAc,CAACkE,IAAI,CAAC,CAAC;MACjF,MAAMC,UAAU,GAAGnB,IAAI,CAACoB,IAAI,CAACN,CAAC,IAAIA,CAAC,CAACzC,IAAI,KAAK0C,UAAU,CAAC;MAExD;MACA,MAAMM,gBAAgB,GAAGF,UAAU,CAACZ,SAAS,CAACa,IAAI,CAChDE,CAAC,IAAIA,CAAC,CAAC1B,IAAI,KAAK,QAAQ,IAAI0B,CAAC,CAACC,IAAI,CAACC,QAAQ,CAAC,iBAAiB,CAAC,CAC/D;MAED,IAAIH,gBAAgB,EAAE;QACpB;QACAF,UAAU,CAACZ,SAAS,GAAGY,UAAU,CAACZ,SAAS,CAACd,MAAM,CAAC6B,CAAC,IAAIA,CAAC,KAAKD,gBAAgB,CAAC;QAE/E;QACA,MAAMI,YAAY,GAAW;UAC3BpD,IAAI,EAAE8C,UAAU,CAAC9C,IAAI,GAAGtB,IAAI;UAC5B2E,MAAM,EAAEP,UAAU,CAAC9C,IAAI;UACvBkC,SAAS,EAAE,CAACc,gBAAgB,CAAC,CAAC;SAC/B;QAEDnB,aAAa,CAACxB,IAAI,CAAC+C,YAAY,CAAC;MAClC;IACF;EACF;EAEA,OAAOxB,aAAa,CAAC0B,MAAM,CAAC3B,IAAI,EAAEE,aAAa,CAAC;AAClD;AAEA,OAAM,SAAU0B,0BAA0BA,CAAC3D,KAAgB,EAAE4D,KAAY;EACvE,KAAK,MAAM3D,OAAO,IAAItB,IAAI,CAACqB,KAAK,CAACE,SAAS,CAACC,SAAS,IAAI,EAAE,CAAC,EAAE;IAC3D,KAAK,MAAMI,CAAC,IAAItC,kBAAkB,EAAE;MAClC,IAAIsC,CAAC,CAACC,OAAO,CAACP,OAAO,CAAC,IAAIM,CAAC,CAACqD,KAAK,EAAE;QACjCA,KAAK,GAAGrD,CAAC,CAACqD,KAAK,CAAC5D,KAAK,EAAEC,OAAO,EAAE2D,KAAK,CAAC;MACxC;IACF;EACF;EAEA,OAAOA,KAAK;AACd;AAEA,OAAM,SAAUC,2BAA2BA,CAAC7D,KAAiB,EAAE4D,KAAY;EACzE,KAAK,MAAME,KAAK,IAAI9D,KAAK,CAAC+D,QAAQ,EAAE;IAClC,IAAInF,WAAW,CAACkF,KAAK,CAAC,EAAE;MACtBF,KAAK,GAAGD,0BAA0B,CAACG,KAAK,EAAEF,KAAK,CAAC;IAClD;EACF;EAEA,OAAOA,KAAK;AACd;AAEA,OAAM,SAAUI,4BAA4BA,CAC1ChE,KAAY,EACZiE,MAAuB,EACvBC,SAAyB,EACzBC,MAAgB;EAEhB,MAAMC,YAAY,GAAGvF,oBAAoB,CAACmB,KAAK,EAAEiE,MAAM,CAACI,KAAK,EAAEJ,MAAM,CAAC;EAEtE,OAAO;IACLrD,MAAM,EACJtC,mBAAmB,CAAC4F,SAAS,CAACI,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI5G,OAAO,CAACyG,MAAM,CAAC,IAAIA,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,GAClF,WAAWC,YAAY,gBAAgBA,YAAY,GAAG,GACtDA;GACP;AACH;AAEA,SAAStD,mBAAmBA,CAAC5B,OAAiB;EAC5C,OAAOA,OAAO,CAACU,GAAG,CAAC6B,CAAC,IAAG;IACrB,IAAIA,CAAC,CAACf,EAAE,IAAI,CAACe,CAAC,CAACf,EAAE,CAACM,MAAM,EAAE,OAAOS,CAAC,CAACf,EAAE;IACrC,OAAOe,CAAC;EACV,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}