{"ast":null,"code":"import * as log from '../log';\nimport { deepEqual, duplicate, getFirstDefined, keys } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class Split {\n  constructor(explicit = {}, implicit = {}) {\n    this.explicit = explicit;\n    this.implicit = implicit;\n  }\n  clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n  combine() {\n    return {\n      ...this.explicit,\n      // Explicit properties comes first\n      ...this.implicit\n    };\n  }\n  get(key) {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n  getWithExplicit(key) {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {\n        explicit: true,\n        value: this.explicit[key]\n      };\n    } else if (this.implicit[key] !== undefined) {\n      return {\n        explicit: false,\n        value: this.implicit[key]\n      };\n    }\n    return {\n      explicit: false,\n      value: undefined\n    };\n  }\n  setWithExplicit(key, {\n    value,\n    explicit\n  }) {\n    if (value !== undefined) {\n      this.set(key, value, explicit);\n    }\n  }\n  set(key, value, explicit) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n  copyKeyFromSplit(key, {\n    explicit,\n    implicit\n  }) {\n    // Explicit has higher precedence\n    if (explicit[key] !== undefined) {\n      this.set(key, explicit[key], true);\n    } else if (implicit[key] !== undefined) {\n      this.set(key, implicit[key], false);\n    }\n  }\n  copyKeyFromObject(key, s) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n  copyAll(other) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n}\nexport function makeExplicit(value) {\n  return {\n    explicit: true,\n    value\n  };\n}\nexport function makeImplicit(value) {\n  return {\n    explicit: false,\n    value\n  };\n}\nexport function tieBreakByComparing(compare) {\n  return (v1, v2, property, propertyOf) => {\n    const diff = compare(v1.value, v2.value);\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n    return defaultTieBreaker(v1, v2, property, propertyOf);\n  };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, prefer v1.\n  return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf, tieBreaker = defaultTieBreaker) {\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}","map":{"version":3,"names":["log","deepEqual","duplicate","getFirstDefined","keys","Split","constructor","explicit","implicit","clone","combine","get","key","getWithExplicit","undefined","value","setWithExplicit","set","copyKeyFromSplit","copyKeyFromObject","s","copyAll","other","val","makeExplicit","makeImplicit","tieBreakByComparing","compare","v1","v2","property","propertyOf","diff","defaultTieBreaker","warn","message","mergeConflictingProperty","mergeValuesWithExplicit","tieBreaker"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\node_modules\\vega-lite\\src\\compile\\split.ts"],"sourcesContent":["import * as log from '../log';\nimport {deepEqual, duplicate, getFirstDefined, keys} from '../util';\n\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class Split<T extends object> {\n  constructor(\n    public readonly explicit: Partial<T> = {},\n    public readonly implicit: Partial<T> = {}\n  ) {}\n\n  public clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n\n  public combine(): Partial<T> {\n    return {\n      ...this.explicit, // Explicit properties comes first\n      ...this.implicit\n    };\n  }\n\n  public get<K extends keyof T>(key: K): T[K] {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n\n  public getWithExplicit<K extends keyof T>(key: K): Explicit<T[K]> {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {explicit: true, value: this.explicit[key]};\n    } else if (this.implicit[key] !== undefined) {\n      return {explicit: false, value: this.implicit[key]};\n    }\n    return {explicit: false, value: undefined};\n  }\n\n  public setWithExplicit<K extends keyof T>(key: K, {value, explicit}: Explicit<T[K]>) {\n    if (value !== undefined) {\n      this.set(key, value, explicit);\n    }\n  }\n\n  public set<K extends keyof T>(key: K, value: T[K], explicit: boolean) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n\n  public copyKeyFromSplit<S extends T>(key: keyof T, {explicit, implicit}: Split<S>) {\n    // Explicit has higher precedence\n    if (explicit[key] !== undefined) {\n      this.set(key, explicit[key], true);\n    } else if (implicit[key] !== undefined) {\n      this.set(key, implicit[key], false);\n    }\n  }\n  public copyKeyFromObject<S extends T>(key: keyof T, s: Partial<S>) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n  public copyAll(other: Split<T>) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n}\n\nexport interface Explicit<T> {\n  explicit: boolean;\n  value: T;\n}\n\nexport function makeExplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: true,\n    value\n  };\n}\n\nexport function makeImplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: false,\n    value\n  };\n}\n\nexport type SplitParentProperty = 'scale' | 'axis' | 'legend' | '';\n\nexport function tieBreakByComparing<S, T>(compare: (v1: T, v2: T) => number) {\n  return (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S | never,\n    propertyOf: SplitParentProperty\n  ): Explicit<T> => {\n    const diff = compare(v1.value, v2.value);\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n    return defaultTieBreaker<S, T>(v1, v2, property, propertyOf);\n  };\n}\n\nexport function defaultTieBreaker<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: SplitParentProperty\n) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, prefer v1.\n  return v1;\n}\n\nexport function mergeValuesWithExplicit<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: SplitParentProperty,\n  tieBreaker: (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S,\n    propertyOf: string\n  ) => Explicit<T> = defaultTieBreaker\n) {\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}