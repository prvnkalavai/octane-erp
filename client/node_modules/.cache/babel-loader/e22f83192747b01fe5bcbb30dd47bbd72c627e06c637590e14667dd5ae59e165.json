{"ast":null,"code":"import { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../bin';\nimport { COLOR, FILL, getSecondaryRangeChannel, isXorY, isXorYOffset, POLAR_POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, STROKE } from '../../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldDef, valueExpr } from '../../channeldef';\nimport { isDateTime } from '../../datetime';\nimport { channelHasNestedOffsetScale } from '../../encoding';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, isContinuousToContinuous, isContinuousToDiscrete, ScaleType, scaleTypeSupportProperty } from '../../scale';\nimport * as util from '../../util';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { parseUnitScaleRange } from './range';\nexport function parseScaleProperty(model, property) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\nfunction parseUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n  const {\n    config,\n    encoding,\n    markDef,\n    specifiedScales\n  } = model;\n  for (const channel of keys(localScaleComponents)) {\n    const specifiedScale = specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n    const specifiedValue = specifiedScale[property];\n    const scaleType = mergedScaleCmpt.get('type');\n    const scalePadding = mergedScaleCmpt.get('padding');\n    const scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n    const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        const timeUnit = fieldOrDatumDef.timeUnit;\n        const type = fieldOrDatumDef.type;\n        switch (property) {\n          // domainMax/Min to signal if the value is a datetime object\n          case 'domainMax':\n          case 'domainMin':\n            if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n              localScaleCmpt.set(property, {\n                signal: valueExpr(specifiedScale[property], {\n                  type,\n                  timeUnit\n                })\n              }, true);\n            } else {\n              localScaleCmpt.set(property, specifiedScale[property], true);\n            }\n            break;\n          default:\n            localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n        }\n      } else {\n        const value = util.hasProperty(scaleRules, property) ? scaleRules[property]({\n          model,\n          channel,\n          fieldOrDatumDef,\n          scaleType,\n          scalePadding,\n          scalePaddingInner,\n          domain: specifiedScale.domain,\n          domainMin: specifiedScale.domainMin,\n          domainMax: specifiedScale.domainMax,\n          markDef,\n          config,\n          hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel),\n          hasSecondaryRangeChannel: !!encoding[getSecondaryRangeChannel(channel)]\n        }) : config.scale[property];\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value, false);\n        }\n      }\n    }\n  }\n}\nexport const scaleRules = {\n  bins: ({\n    model,\n    fieldOrDatumDef\n  }) => isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : undefined,\n  interpolate: ({\n    channel,\n    fieldOrDatumDef\n  }) => interpolate(channel, fieldOrDatumDef.type),\n  nice: ({\n    scaleType,\n    channel,\n    domain,\n    domainMin,\n    domainMax,\n    fieldOrDatumDef\n  }) => nice(scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef),\n  padding: ({\n    channel,\n    scaleType,\n    fieldOrDatumDef,\n    markDef,\n    config\n  }) => padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar),\n  paddingInner: ({\n    scalePadding,\n    channel,\n    markDef,\n    scaleType,\n    config,\n    hasNestedOffsetScale\n  }) => paddingInner(scalePadding, channel, markDef.type, scaleType, config.scale, hasNestedOffsetScale),\n  paddingOuter: ({\n    scalePadding,\n    channel,\n    scaleType,\n    scalePaddingInner,\n    config,\n    hasNestedOffsetScale\n  }) => paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, config.scale, hasNestedOffsetScale),\n  reverse: ({\n    fieldOrDatumDef,\n    scaleType,\n    channel,\n    config\n  }) => {\n    const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n    return reverse(scaleType, sort, channel, config.scale);\n  },\n  zero: ({\n    channel,\n    fieldOrDatumDef,\n    domain,\n    markDef,\n    scaleType,\n    config,\n    hasSecondaryRangeChannel\n  }) => zero(channel, fieldOrDatumDef, domain, markDef, scaleType, config.scale, hasSecondaryRangeChannel)\n};\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\nexport function parseNonUnitScaleProperty(model, property) {\n  const localScaleComponents = model.component.scales;\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n  for (const channel of keys(localScaleComponents)) {\n    let valueWithExplicit;\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, 'scale', tieBreakByComparing((v1, v2) => {\n          switch (property) {\n            case 'range':\n              // For step, prefer larger step\n              if (v1.step && v2.step) {\n                return v1.step - v2.step;\n              }\n              return 0;\n            // TODO: precedence rule for other properties\n          }\n          return 0;\n        }));\n      }\n    }\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  }\n}\nexport function bins(model, fieldDef) {\n  const bin = fieldDef.bin;\n  if (isBinning(bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(() => {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n  return undefined;\n}\nexport function interpolate(channel, type) {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n  return undefined;\n}\nexport function nice(scaleType, channel, specifiedDomain, domainMin, domainMax, fieldOrDatumDef) {\n  if (getFieldDef(fieldOrDatumDef)?.bin || isArray(specifiedDomain) || domainMax != null || domainMin != null || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n  return isXorY(channel) ? true : undefined;\n}\nexport function padding(channel, scaleType, scaleConfig, fieldOrDatumDef, markDef, barConfig) {\n  if (isXorY(channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n      const {\n        type,\n        orient\n      } = markDef;\n      if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n        if (orient === 'vertical' && channel === 'x' || orient === 'horizontal' && channel === 'y') {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\nexport function paddingInner(paddingValue, channel, mark, scaleType, scaleConfig, hasNestedOffsetScale = false) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n  if (isXorY(channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    const {\n      bandPaddingInner,\n      barBandPaddingInner,\n      rectBandPaddingInner,\n      tickBandPaddingInner,\n      bandWithNestedOffsetPaddingInner\n    } = scaleConfig;\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingInner;\n    }\n    return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : mark === 'tick' ? tickBandPaddingInner : rectBandPaddingInner);\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingInner;\n    }\n  }\n  return undefined;\n}\nexport function paddingOuter(paddingValue, channel, scaleType, paddingInnerValue, scaleConfig, hasNestedOffsetScale = false) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n  if (isXorY(channel)) {\n    const {\n      bandPaddingOuter,\n      bandWithNestedOffsetPaddingOuter\n    } = scaleConfig;\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingOuter;\n    }\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      return getFirstDefined(bandPaddingOuter,\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n        size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n        and we want the width/height to be integer by default.\n        Note that step (by default) and cardinality are integers.) */\n      isSignalRef(paddingInnerValue) ? {\n        signal: `${paddingInnerValue.signal}/2`\n      } : paddingInnerValue / 2);\n    }\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.POINT) {\n      return 0.5; // so the point positions align with centers of band scales.\n    } else if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingOuter;\n    }\n  }\n  return undefined;\n}\nexport function reverse(scaleType, sort, channel, scaleConfig) {\n  if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n      if (isSignalRef(scaleConfig.xReverse)) {\n        return {\n          signal: `!${scaleConfig.xReverse.signal}`\n        };\n      } else {\n        return !scaleConfig.xReverse;\n      }\n    }\n    return scaleConfig.xReverse;\n  }\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n  return undefined;\n}\nexport function zero(channel, fieldDef, specifiedDomain, markDef, scaleType, scaleConfig, hasSecondaryRangeChannel) {\n  // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        const first = specifiedDomain[0];\n        const last = specifiedDomain[specifiedDomain.length - 1];\n        if (isNumber(first) && first <= 0 && isNumber(last) && last >= 0) {\n          // if the domain includes zero, make zero remain true\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  // If there is no custom domain, return configZero value (=`true` as default) only for the following cases:\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  }\n  // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n  // (For area/bar charts with ratio scale chart, we should always include zero.)\n  if (!(isFieldDef(fieldDef) && fieldDef.bin) && util.contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {\n    const {\n      orient,\n      type\n    } = markDef;\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if (orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x') {\n        return false;\n      }\n    }\n    if (contains(['bar', 'area'], type) && !hasSecondaryRangeChannel) {\n      return true;\n    }\n    return scaleConfig?.zero;\n  }\n  return false;\n}","map":{"version":3,"names":["isArray","isNumber","isBinned","isBinning","isBinParams","COLOR","FILL","getSecondaryRangeChannel","isXorY","isXorYOffset","POLAR_POSITION_SCALE_CHANNELS","POSITION_SCALE_CHANNELS","STROKE","getFieldDef","getFieldOrDatumDef","isFieldDef","valueExpr","isDateTime","channelHasNestedOffsetScale","log","channelScalePropertyIncompatability","hasContinuousDomain","isContinuousToContinuous","isContinuousToDiscrete","ScaleType","scaleTypeSupportProperty","util","contains","getFirstDefined","keys","isSignalRef","getBinSignalName","isUnitModel","SignalRefWrapper","mergeValuesWithExplicit","tieBreakByComparing","parseUnitScaleRange","parseScaleProperty","model","property","parseUnitScaleProperty","parseNonUnitScaleProperty","localScaleComponents","component","scales","config","encoding","markDef","specifiedScales","channel","specifiedScale","localScaleCmpt","mergedScaleCmpt","getScaleComponent","fieldOrDatumDef","specifiedValue","scaleType","get","scalePadding","scalePaddingInner","supportedByScaleType","channelIncompatability","undefined","warn","message","scalePropertyNotWorkWithScaleType","timeUnit","type","set","signal","copyKeyFromObject","value","hasProperty","scaleRules","domain","domainMin","domainMax","hasNestedOffsetScale","hasSecondaryRangeChannel","scale","bins","interpolate","nice","padding","bar","paddingInner","paddingOuter","reverse","sort","zero","parseScaleRange","child","children","valueWithExplicit","childComponent","childValueWithExplicit","getWithExplicit","v1","v2","step","setWithExplicit","fieldDef","bin","binSignal","field","getSignalName","specifiedDomain","TIME","UTC","scaleConfig","barConfig","continuousPadding","orient","continuousBandSize","POINT","pointPadding","paddingValue","mark","bandPaddingInner","barBandPaddingInner","rectBandPaddingInner","tickBandPaddingInner","bandWithNestedOffsetPaddingInner","BAND","offsetBandPaddingInner","paddingInnerValue","bandPaddingOuter","bandWithNestedOffsetPaddingOuter","offsetBandPaddingOuter","xReverse","hasCustomDomain","first","last","length"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\client\\node_modules\\vega-lite\\src\\compile\\scale\\properties.ts"],"sourcesContent":["import {SignalRef, TimeInterval} from 'vega';\nimport {isArray, isNumber} from 'vega-util';\nimport {isBinned, isBinning, isBinParams} from '../../bin';\nimport {\n  COLOR,\n  FILL,\n  getSecondaryRangeChannel,\n  isXorY,\n  isXorYOffset,\n  POLAR_POSITION_SCALE_CHANNELS,\n  POSITION_SCALE_CHANNELS,\n  ScaleChannel,\n  STROKE\n} from '../../channel';\nimport {\n  getFieldDef,\n  getFieldOrDatumDef,\n  isFieldDef,\n  ScaleDatumDef,\n  ScaleFieldDef,\n  TypedFieldDef,\n  valueExpr\n} from '../../channeldef';\nimport {Config} from '../../config';\nimport {isDateTime} from '../../datetime';\nimport {channelHasNestedOffsetScale} from '../../encoding';\nimport * as log from '../../log';\nimport {Mark, MarkDef, RectConfig} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  isContinuousToContinuous,\n  isContinuousToDiscrete,\n  Scale,\n  ScaleConfig,\n  ScaleType,\n  scaleTypeSupportProperty\n} from '../../scale';\nimport {Sort} from '../../sort';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {contains, getFirstDefined, keys} from '../../util';\nimport {isSignalRef, VgScale} from '../../vega.schema';\nimport {getBinSignalName} from '../data/bin';\nimport {isUnitModel, Model} from '../model';\nimport {SignalRefWrapper} from '../signal';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex, ScaleComponentProps} from './component';\nimport {parseUnitScaleRange} from './range';\n\nexport function parseScaleProperty(model: Model, property: Exclude<keyof (Scale | ScaleComponentProps), 'range'>) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\n\nfunction parseUnitScaleProperty(model: UnitModel, property: Exclude<keyof (Scale | ScaleComponentProps), 'range'>) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n  const {config, encoding, markDef, specifiedScales} = model;\n\n  for (const channel of keys(localScaleComponents)) {\n    const specifiedScale = specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as ScaleFieldDef<string, Type> | ScaleDatumDef;\n\n    const specifiedValue = specifiedScale[property];\n    const scaleType = mergedScaleCmpt.get('type');\n    const scalePadding = mergedScaleCmpt.get('padding');\n    const scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n\n    const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        const timeUnit = (fieldOrDatumDef as any).timeUnit;\n        const type = fieldOrDatumDef.type;\n\n        switch (property) {\n          // domainMax/Min to signal if the value is a datetime object\n          case 'domainMax':\n          case 'domainMin':\n            if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n              localScaleCmpt.set(property, {signal: valueExpr(specifiedScale[property], {type, timeUnit})}, true);\n            } else {\n              localScaleCmpt.set(property, specifiedScale[property] as any, true);\n            }\n            break;\n          default:\n            localScaleCmpt.copyKeyFromObject<Omit<ScaleComponentProps, 'range' | 'domainMin' | 'domainMax'>>(\n              property,\n              specifiedScale\n            );\n        }\n      } else {\n        const value = util.hasProperty(scaleRules, property)\n          ? scaleRules[property]({\n              model,\n              channel,\n              fieldOrDatumDef,\n              scaleType,\n              scalePadding,\n              scalePaddingInner,\n              domain: specifiedScale.domain,\n              domainMin: specifiedScale.domainMin,\n              domainMax: specifiedScale.domainMax,\n              markDef,\n              config,\n              hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel),\n              hasSecondaryRangeChannel: !!encoding[getSecondaryRangeChannel(channel)]\n            })\n          : config.scale[property];\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value as any, false);\n        }\n      }\n    }\n  }\n}\n\nexport interface ScaleRuleParams {\n  model: Model;\n  channel: ScaleChannel;\n  fieldOrDatumDef: ScaleFieldDef<string, Type> | ScaleDatumDef;\n  hasNestedOffsetScale: boolean;\n  scaleType: ScaleType;\n  scalePadding: number | SignalRef;\n  scalePaddingInner: number | SignalRef;\n  domain: Domain;\n  domainMin: Scale['domainMin'];\n  domainMax: Scale['domainMax'];\n  markDef: MarkDef<Mark, SignalRef>;\n  config: Config<SignalRef>;\n  hasSecondaryRangeChannel: boolean;\n}\n\nexport const scaleRules: {\n  [k in keyof Scale]?: (params: ScaleRuleParams) => Scale[k];\n} = {\n  bins: ({model, fieldOrDatumDef}) => (isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : undefined),\n\n  interpolate: ({channel, fieldOrDatumDef}) => interpolate(channel, fieldOrDatumDef.type),\n\n  nice: ({scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef}) =>\n    nice(scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef),\n\n  padding: ({channel, scaleType, fieldOrDatumDef, markDef, config}) =>\n    padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar),\n\n  paddingInner: ({scalePadding, channel, markDef, scaleType, config, hasNestedOffsetScale}) =>\n    paddingInner(scalePadding, channel, markDef.type, scaleType, config.scale, hasNestedOffsetScale),\n\n  paddingOuter: ({scalePadding, channel, scaleType, scalePaddingInner, config, hasNestedOffsetScale}) =>\n    paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, config.scale, hasNestedOffsetScale),\n\n  reverse: ({fieldOrDatumDef, scaleType, channel, config}) => {\n    const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n    return reverse(scaleType, sort, channel, config.scale);\n  },\n  zero: ({channel, fieldOrDatumDef, domain, markDef, scaleType, config, hasSecondaryRangeChannel}) =>\n    zero(channel, fieldOrDatumDef, domain, markDef, scaleType, config.scale, hasSecondaryRangeChannel)\n};\n\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\n\nexport function parseNonUnitScaleProperty(model: Model, property: keyof (Scale | ScaleComponentProps)) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n\n  for (const channel of keys(localScaleComponents)) {\n    let valueWithExplicit: Explicit<any>;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit<VgScale, any>(\n          valueWithExplicit,\n          childValueWithExplicit,\n          property,\n          'scale',\n          tieBreakByComparing<VgScale, any>((v1, v2) => {\n            switch (property) {\n              case 'range':\n                // For step, prefer larger step\n                if (v1.step && v2.step) {\n                  return v1.step - v2.step;\n                }\n                return 0;\n              // TODO: precedence rule for other properties\n            }\n            return 0;\n          })\n        );\n      }\n    }\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  }\n}\n\nexport function bins(model: Model, fieldDef: TypedFieldDef<string>) {\n  const bin = fieldDef.bin;\n  if (isBinning(bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(() => {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n  return undefined;\n}\n\nexport function interpolate(channel: ScaleChannel, type: Type): Scale['interpolate'] {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n  return undefined;\n}\n\nexport function nice(\n  scaleType: ScaleType,\n  channel: ScaleChannel,\n  specifiedDomain: Domain,\n  domainMin: Scale['domainMin'],\n  domainMax: Scale['domainMax'],\n  fieldOrDatumDef: TypedFieldDef<string> | ScaleDatumDef\n): boolean | TimeInterval {\n  if (\n    getFieldDef(fieldOrDatumDef)?.bin ||\n    isArray(specifiedDomain) ||\n    domainMax != null ||\n    domainMin != null ||\n    util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)\n  ) {\n    return undefined;\n  }\n  return isXorY(channel) ? true : undefined;\n}\n\nexport function padding(\n  channel: ScaleChannel,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig<SignalRef>,\n  fieldOrDatumDef: TypedFieldDef<string> | ScaleDatumDef,\n  markDef: MarkDef<Mark, SignalRef>,\n  barConfig: RectConfig<SignalRef>\n) {\n  if (isXorY(channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n\n      const {type, orient} = markDef;\n      if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n        if ((orient === 'vertical' && channel === 'x') || (orient === 'horizontal' && channel === 'y')) {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingInner(\n  paddingValue: number | SignalRef,\n  channel: ScaleChannel,\n  mark: Mark,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig<SignalRef>,\n  hasNestedOffsetScale = false\n) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (isXorY(channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    const {\n      bandPaddingInner,\n      barBandPaddingInner,\n      rectBandPaddingInner,\n      tickBandPaddingInner,\n      bandWithNestedOffsetPaddingInner\n    } = scaleConfig;\n\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingInner;\n    }\n\n    return getFirstDefined(\n      bandPaddingInner,\n      mark === 'bar' ? barBandPaddingInner : mark === 'tick' ? tickBandPaddingInner : rectBandPaddingInner\n    );\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingInner;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingOuter(\n  paddingValue: number | SignalRef,\n  channel: ScaleChannel,\n  scaleType: ScaleType,\n  paddingInnerValue: number | SignalRef,\n  scaleConfig: ScaleConfig<SignalRef>,\n  hasNestedOffsetScale = false\n) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (isXorY(channel)) {\n    const {bandPaddingOuter, bandWithNestedOffsetPaddingOuter} = scaleConfig;\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingOuter;\n    }\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      return getFirstDefined(\n        bandPaddingOuter,\n        /* By default, paddingOuter is paddingInner / 2. The reason is that\n          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n          and we want the width/height to be integer by default.\n          Note that step (by default) and cardinality are integers.) */\n        isSignalRef(paddingInnerValue) ? {signal: `${paddingInnerValue.signal}/2`} : paddingInnerValue / 2\n      );\n    }\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.POINT) {\n      return 0.5; // so the point positions align with centers of band scales.\n    } else if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingOuter;\n    }\n  }\n  return undefined;\n}\n\nexport function reverse(\n  scaleType: ScaleType,\n  sort: Sort<string>,\n  channel: ScaleChannel,\n  scaleConfig: ScaleConfig<SignalRef>\n) {\n  if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n      if (isSignalRef(scaleConfig.xReverse)) {\n        return {signal: `!${scaleConfig.xReverse.signal}`};\n      } else {\n        return !scaleConfig.xReverse;\n      }\n    }\n    return scaleConfig.xReverse;\n  }\n\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n  return undefined;\n}\n\nexport function zero(\n  channel: ScaleChannel,\n  fieldDef: TypedFieldDef<string> | ScaleDatumDef,\n  specifiedDomain: Domain,\n  markDef: MarkDef,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig<SignalRef>,\n  hasSecondaryRangeChannel: boolean\n) {\n  // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        const first = specifiedDomain[0];\n        const last = specifiedDomain[specifiedDomain.length - 1];\n\n        if (isNumber(first) && first <= 0 && isNumber(last) && last >= 0) {\n          // if the domain includes zero, make zero remain true\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  // If there is no custom domain, return configZero value (=`true` as default) only for the following cases:\n\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  }\n\n  // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n  // (For area/bar charts with ratio scale chart, we should always include zero.)\n  if (\n    !(isFieldDef(fieldDef) && fieldDef.bin) &&\n    util.contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)\n  ) {\n    const {orient, type} = markDef;\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if ((orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x')) {\n        return false;\n      }\n    }\n\n    if (contains(['bar', 'area'], type) && !hasSecondaryRangeChannel) {\n      return true;\n    }\n\n    return scaleConfig?.zero;\n  }\n\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}