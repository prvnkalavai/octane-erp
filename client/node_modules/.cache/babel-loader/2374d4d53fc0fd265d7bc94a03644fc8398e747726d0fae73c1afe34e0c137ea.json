{"ast":null,"code":"import { array, isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { isText } from '../../title';\nimport { contains, getFirstDefined, isEmpty, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromValueRefOrSignalRef } from '../common';\nimport { expression } from '../predicate';\nfunction assembleTitle(title, config) {\n  if (!title) {\n    return undefined;\n  }\n  if (isArray(title) && !isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n  return title;\n}\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n  var _a, _b;\n  axis.encode ?? (axis.encode = {});\n  (_a = axis.encode)[part] ?? (_a[part] = {});\n  (_b = axis.encode[part]).update ?? (_b.update = {});\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  axis.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleAxis(axisCmpt, kind, config, opt = {\n  header: false\n}) {\n  const {\n    disable,\n    orient,\n    scale,\n    labelExpr,\n    title,\n    zindex,\n    ...axis\n  } = axisCmpt.combine();\n  if (disable) {\n    return undefined;\n  }\n  for (const p in axis) {\n    const prop = p;\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      // deal with conditional axis value\n      const {\n        condition,\n        ...valueOrSignalRef\n      } = propValue;\n      const conditions = array(condition);\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex;\n        // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n        const vgRef = [...conditions.map(c => {\n          const {\n            test,\n            ...valueOrSignalCRef\n          } = c;\n          return {\n            test: expression(null, test),\n            ...valueOrSignalCRef\n          };\n        }), valueOrSignalRef];\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n        const signalRef = {\n          signal: conditions.map(c => {\n            const {\n              test,\n              ...valueOrSignalCRef\n            } = c;\n            return `${expression(null, test)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;\n          }).join('') + exprFromValueRefOrSignalRef(valueOrSignalRef)\n        };\n        axis[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        const {\n          vgProp,\n          part\n        } = propIndex;\n        // FIXME: remove as any\n        setAxisEncode(axis, part, vgProp, propValue);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n    }\n    // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n    // Note that we need to use null so the default labelAlign is preserved.\n    if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n      delete axis[prop];\n    }\n  }\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    }\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {\n        grid\n      } = axis.encode;\n      axis.encode = {\n        ...(grid ? {\n          grid\n        } : {})\n      };\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n    return {\n      scale,\n      orient,\n      ...axis,\n      domain: false,\n      labels: false,\n      aria: false,\n      // always hide grid axis\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n    };\n  } else {\n    // kind === 'main'\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n      if (axis.encode?.labels?.update && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n      setAxisEncode(axis, 'labels', 'text', {\n        signal: expr\n      });\n    }\n    if (axis.labelAlign === null) {\n      delete axis.labelAlign;\n    }\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n    const titleString = assembleTitle(title, config);\n    return {\n      scale,\n      orient,\n      grid: false,\n      ...(titleString ? {\n        title: titleString\n      } : {}),\n      ...axis,\n      ...(config.aria === false ? {\n        aria: false\n      } : {}),\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n    };\n  }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model) {\n  const {\n    axes\n  } = model.component;\n  const signals = [];\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('disable') && !axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          const update = model.getSizeSignalRef(sizeType).signal;\n          if (sizeType !== update) {\n            signals.push({\n              name: sizeType,\n              update\n            });\n          }\n        }\n      }\n    }\n  }\n  return signals;\n}\nexport function assembleAxes(axisComponents, config) {\n  const {\n    x = [],\n    y = []\n  } = axisComponents;\n  return [...x.map(a => assembleAxis(a, 'grid', config)), ...y.map(a => assembleAxis(a, 'grid', config)), ...x.map(a => assembleAxis(a, 'main', config)), ...y.map(a => assembleAxis(a, 'main', config))].filter(a => a); // filter undefined\n}","map":{"version":3,"names":["array","isArray","AXIS_PARTS","AXIS_PROPERTY_TYPE","CONDITIONAL_AXIS_PROP_INDEX","isConditionalAxisValue","POSITION_SCALE_CHANNELS","defaultTitle","isText","contains","getFirstDefined","isEmpty","replaceAll","isSignalRef","exprFromValueRefOrSignalRef","expression","assembleTitle","title","config","undefined","map","fieldDef","join","setAxisEncode","axis","part","vgProp","vgRef","encode","_a","_b","update","assembleAxis","axisCmpt","kind","opt","header","disable","orient","scale","labelExpr","zindex","combine","p","prop","propType","propValue","condition","valueOrSignalRef","conditions","propIndex","c","test","valueOrSignalCRef","signalRef","signal","grid","domain","labels","aria","maxExtent","minExtent","ticks","mainExtracted","expr","text","labelAlign","hasAxisPart","titleString","assembleAxisSignals","model","axes","component","signals","channel","get","sizeType","getSizeSignalRef","push","name","assembleAxes","axisComponents","x","y","a","filter"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\node_modules\\vega-lite\\src\\compile\\axis\\assemble.ts"],"sourcesContent":["import {Axis as VgAxis, AxisEncode, NewSignal, SignalRef, Text} from 'vega';\nimport {array, isArray} from 'vega-util';\nimport {\n  AXIS_PARTS,\n  AXIS_PROPERTY_TYPE,\n  CONDITIONAL_AXIS_PROP_INDEX,\n  ConditionalAxisProp,\n  isConditionalAxisValue\n} from '../../axis';\nimport {POSITION_SCALE_CHANNELS} from '../../channel';\nimport {defaultTitle, FieldDefBase} from '../../channeldef';\nimport {Config} from '../../config';\nimport {isText} from '../../title';\nimport {contains, getFirstDefined, isEmpty, replaceAll} from '../../util';\nimport {isSignalRef, VgEncodeChannel, VgValueRef} from '../../vega.schema';\nimport {exprFromValueRefOrSignalRef} from '../common';\nimport {Model} from '../model';\nimport {expression} from '../predicate';\nimport {AxisComponent, AxisComponentIndex} from './component';\n\nfunction assembleTitle(title: Text | FieldDefBase<string>[] | SignalRef, config: Config): Text | SignalRef {\n  if (!title) {\n    return undefined;\n  }\n  if (isArray(title) && !isText(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n  return title;\n}\n\nfunction setAxisEncode(\n  axis: Omit<VgAxis, 'orient' | 'scale'>,\n  part: keyof AxisEncode,\n  vgProp: VgEncodeChannel,\n  vgRef: VgValueRef | readonly VgValueRef[]\n) {\n  axis.encode ??= {};\n  axis.encode[part] ??= {};\n  axis.encode[part].update ??= {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  (axis.encode[part].update[vgProp] as any) = vgRef;\n}\n\nexport function assembleAxis(\n  axisCmpt: AxisComponent,\n  kind: 'main' | 'grid',\n  config: Config<SignalRef>,\n  opt: {\n    header: boolean; // whether this is called via a header\n  } = {header: false}\n): VgAxis {\n  const {disable, orient, scale, labelExpr, title, zindex, ...axis} = axisCmpt.combine();\n\n  if (disable) {\n    return undefined;\n  }\n\n  for (const p in axis) {\n    const prop = p as keyof typeof axis;\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue<any, SignalRef>(propValue)) {\n      // deal with conditional axis value\n\n      const {condition, ...valueOrSignalRef} = propValue as any;\n      const conditions = array(condition);\n\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop as ConditionalAxisProp];\n      if (propIndex) {\n        const {vgProp, part} = propIndex;\n        // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n\n        const vgRef = [\n          ...conditions.map(c => {\n            const {test, ...valueOrSignalCRef} = c;\n            return {\n              test: expression(null, test),\n              ...valueOrSignalCRef\n            };\n          }),\n          valueOrSignalRef\n        ];\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n        const signalRef: SignalRef = {\n          signal:\n            conditions\n              .map(c => {\n                const {test, ...valueOrSignalCRef} = c;\n                return `${expression(null, test)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;\n              })\n              .join('') + exprFromValueRefOrSignalRef(valueOrSignalRef)\n        };\n        (axis as any)[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop as ConditionalAxisProp];\n      if (propIndex) {\n        const {vgProp, part} = propIndex;\n        // FIXME: remove as any\n        setAxisEncode(axis, part, vgProp, propValue as any);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n    }\n\n    // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n    // Note that we need to use null so the default labelAlign is preserved.\n    if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n      delete axis[prop];\n    }\n  }\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {grid} = axis.encode;\n      axis.encode = {\n        ...(grid ? {grid} : {})\n      };\n\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    return {\n      scale,\n      orient,\n      ...axis,\n      domain: false,\n      labels: false,\n      aria: false, // always hide grid axis\n\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n    };\n  } else {\n    // kind === 'main'\n\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n      if (axis.encode?.labels?.update && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n      setAxisEncode(axis, 'labels', 'text', {signal: expr});\n    }\n\n    if (axis.labelAlign === null) {\n      delete axis.labelAlign;\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n\n    const titleString = assembleTitle(title, config);\n\n    return {\n      scale,\n      orient,\n      grid: false,\n      ...(titleString ? {title: titleString} : {}),\n      ...axis,\n      ...(config.aria === false ? {aria: false} : {}),\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n    };\n  }\n}\n\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model: Model): NewSignal[] {\n  const {axes} = model.component;\n  const signals: NewSignal[] = [];\n\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('disable') && !axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          const update = model.getSizeSignalRef(sizeType).signal;\n\n          if (sizeType !== update) {\n            signals.push({\n              name: sizeType,\n              update\n            });\n          }\n        }\n      }\n    }\n  }\n  return signals;\n}\n\nexport function assembleAxes(axisComponents: AxisComponentIndex, config: Config<SignalRef>): VgAxis[] {\n  const {x = [], y = []} = axisComponents;\n  return [\n    ...x.map(a => assembleAxis(a, 'grid', config)),\n    ...y.map(a => assembleAxis(a, 'grid', config)),\n    ...x.map(a => assembleAxis(a, 'main', config)),\n    ...y.map(a => assembleAxis(a, 'main', config))\n  ].filter(a => a); // filter undefined\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}