{"ast":null,"code":"import { isConditionalDef } from '../../../channeldef';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { wrapCondition } from './conditional';\nimport * as ref from './valueref';\nimport { getConditionalValueRefForIncludingInvalidValue } from './invalid';\n/**\n * Return encode for non-positional channels with scales. (Text doesn't have scale.)\n */\nexport function nonPosition(channel, model, opt = {}) {\n  const {\n    markDef,\n    encoding,\n    config\n  } = model;\n  const {\n    vgChannel\n  } = opt;\n  let {\n    defaultRef,\n    defaultValue\n  } = opt;\n  const channelDef = encoding[channel];\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue ?? (defaultValue = getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel,\n      // If there is no conditonal def, we ignore vgConfig so the output spec is concise.\n      // However, if there is a conditional def, we must include vgConfig so the default is respected.\n      ignoreVgConfig: !isConditionalDef(channelDef)\n    }));\n    if (defaultValue !== undefined) {\n      defaultRef = signalOrValueRef(defaultValue);\n    }\n  }\n  const commonProps = {\n    markDef,\n    config,\n    scaleName: model.scaleName(channel),\n    scale: model.getScaleComponent(channel)\n  };\n  const invalidValueRef = getConditionalValueRefForIncludingInvalidValue({\n    ...commonProps,\n    scaleChannel: channel,\n    channelDef\n  });\n  const mainRefFn = cDef => {\n    return ref.midPoint({\n      ...commonProps,\n      channel,\n      channelDef: cDef,\n      stack: null,\n      // No need to provide stack for non-position as it does not affect mid point\n      defaultRef\n    });\n  };\n  return wrapCondition({\n    model,\n    channelDef,\n    vgChannel: vgChannel ?? channel,\n    invalidValueRef,\n    mainRefFn\n  });\n}","map":{"version":3,"names":["isConditionalDef","getMarkPropOrConfig","signalOrValueRef","wrapCondition","ref","getConditionalValueRefForIncludingInvalidValue","nonPosition","channel","model","opt","markDef","encoding","config","vgChannel","defaultRef","defaultValue","channelDef","undefined","ignoreVgConfig","commonProps","scaleName","scale","getScaleComponent","invalidValueRef","scaleChannel","mainRefFn","cDef","midPoint","stack"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\nonposition.ts"],"sourcesContent":["import type {SignalRef} from 'vega';\nimport {NonPositionScaleChannel} from '../../../channel';\nimport {Value, isConditionalDef} from '../../../channeldef';\nimport {VgEncodeChannel, VgEncodeEntry, VgValueRef} from '../../../vega.schema';\nimport {getMarkPropOrConfig, signalOrValueRef} from '../../common';\nimport {UnitModel} from '../../unit';\nimport {wrapCondition} from './conditional';\nimport * as ref from './valueref';\nimport {getConditionalValueRefForIncludingInvalidValue} from './invalid';\n\n/**\n * Return encode for non-positional channels with scales. (Text doesn't have scale.)\n */\nexport function nonPosition(\n  channel: NonPositionScaleChannel,\n  model: UnitModel,\n  opt: {\n    defaultValue?: Value | SignalRef;\n    vgChannel?: VgEncodeChannel;\n    defaultRef?: VgValueRef;\n  } = {}\n): VgEncodeEntry {\n  const {markDef, encoding, config} = model;\n  const {vgChannel} = opt;\n  let {defaultRef, defaultValue} = opt;\n\n  const channelDef = encoding[channel];\n\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue ??= getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel,\n      // If there is no conditonal def, we ignore vgConfig so the output spec is concise.\n      // However, if there is a conditional def, we must include vgConfig so the default is respected.\n      ignoreVgConfig: !isConditionalDef(channelDef)\n    });\n\n    if (defaultValue !== undefined) {\n      defaultRef = signalOrValueRef(defaultValue);\n    }\n  }\n\n  const commonProps = {\n    markDef,\n    config,\n    scaleName: model.scaleName(channel),\n    scale: model.getScaleComponent(channel)\n  };\n\n  const invalidValueRef = getConditionalValueRefForIncludingInvalidValue({\n    ...commonProps,\n    scaleChannel: channel,\n    channelDef\n  });\n\n  const mainRefFn = (cDef: typeof channelDef) => {\n    return ref.midPoint({\n      ...commonProps,\n      channel,\n      channelDef: cDef,\n      stack: null, // No need to provide stack for non-position as it does not affect mid point\n      defaultRef\n    });\n  };\n\n  return wrapCondition({\n    model,\n    channelDef,\n    vgChannel: vgChannel ?? channel,\n    invalidValueRef,\n    mainRefFn\n  });\n}\n"],"mappings":"AAEA,SAAeA,gBAAgB,QAAO,qBAAqB;AAE3D,SAAQC,mBAAmB,EAAEC,gBAAgB,QAAO,cAAc;AAElE,SAAQC,aAAa,QAAO,eAAe;AAC3C,OAAO,KAAKC,GAAG,MAAM,YAAY;AACjC,SAAQC,8CAA8C,QAAO,WAAW;AAExE;;;AAGA,OAAM,SAAUC,WAAWA,CACzBC,OAAgC,EAChCC,KAAgB,EAChBC,GAAA,GAII,EAAE;EAEN,MAAM;IAACC,OAAO;IAAEC,QAAQ;IAAEC;EAAM,CAAC,GAAGJ,KAAK;EACzC,MAAM;IAACK;EAAS,CAAC,GAAGJ,GAAG;EACvB,IAAI;IAACK,UAAU;IAAEC;EAAY,CAAC,GAAGN,GAAG;EAEpC,MAAMO,UAAU,GAAGL,QAAQ,CAACJ,OAAO,CAAC;EAEpC,IAAIO,UAAU,KAAKG,SAAS,EAAE;IAC5B;IACAF,YAAY,KAAZA,YAAY,GAAKd,mBAAmB,CAACM,OAAO,EAAEG,OAAO,EAAEE,MAAM,EAAE;MAC7DC,SAAS;MACT;MACA;MACAK,cAAc,EAAE,CAAClB,gBAAgB,CAACgB,UAAU;KAC7C,CAAC;IAEF,IAAID,YAAY,KAAKE,SAAS,EAAE;MAC9BH,UAAU,GAAGZ,gBAAgB,CAACa,YAAY,CAAC;IAC7C;EACF;EAEA,MAAMI,WAAW,GAAG;IAClBT,OAAO;IACPE,MAAM;IACNQ,SAAS,EAAEZ,KAAK,CAACY,SAAS,CAACb,OAAO,CAAC;IACnCc,KAAK,EAAEb,KAAK,CAACc,iBAAiB,CAACf,OAAO;GACvC;EAED,MAAMgB,eAAe,GAAGlB,8CAA8C,CAAC;IACrE,GAAGc,WAAW;IACdK,YAAY,EAAEjB,OAAO;IACrBS;GACD,CAAC;EAEF,MAAMS,SAAS,GAAIC,IAAuB,IAAI;IAC5C,OAAOtB,GAAG,CAACuB,QAAQ,CAAC;MAClB,GAAGR,WAAW;MACdZ,OAAO;MACPS,UAAU,EAAEU,IAAI;MAChBE,KAAK,EAAE,IAAI;MAAE;MACbd;KACD,CAAC;EACJ,CAAC;EAED,OAAOX,aAAa,CAAC;IACnBK,KAAK;IACLQ,UAAU;IACVH,SAAS,EAAEA,SAAS,IAAIN,OAAO;IAC/BgB,eAAe;IACfE;GACD,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}