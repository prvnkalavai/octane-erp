{"ast":null,"code":"/**\r\n * Copyright 2024 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nimport { EventEmitter } from \"eventemitter3\";\nimport { difference } from \"lodash\";\nimport { isInterrupted, isModelTurn, isServerContenteMessage, isSetupCompleteMessage, isToolCallCancellationMessage, isToolCallMessage, isTurnComplete } from \"../multimodal-live-types\";\nimport { blobToJSON, base64ToArrayBuffer } from \"./utils\";\n\n/**\r\n * the events that this client will emit\r\n */\n\n/**\r\n * A event-emitting class that manages the connection to the websocket and emits\r\n * events to the rest of the application.\r\n * If you dont want to use react you can still use this.\r\n */\nexport class MultimodalLiveClient extends EventEmitter {\n  getConfig() {\n    return {\n      ...this.config\n    };\n  }\n  constructor({\n    url,\n    apiKey\n  }) {\n    super();\n    this.ws = null;\n    this.config = null;\n    this.url = \"\";\n    url = url || `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent`;\n    url += `?key=${apiKey}`;\n    this.url = url;\n    this.send = this.send.bind(this);\n  }\n  log(type, message) {\n    const log = {\n      date: new Date(),\n      type,\n      message\n    };\n    this.emit(\"log\", log);\n  }\n  connect(config) {\n    this.config = config;\n    const ws = new WebSocket(this.url);\n    ws.addEventListener(\"message\", async evt => {\n      if (evt.data instanceof Blob) {\n        this.receive(evt.data);\n      } else {\n        console.log(\"non blob message\", evt);\n      }\n    });\n    return new Promise((resolve, reject) => {\n      const onError = ev => {\n        this.disconnect(ws);\n        const message = `Could not connect to \"${this.url}\"`;\n        this.log(`server.${ev.type}`, message);\n        reject(new Error(message));\n      };\n      ws.addEventListener(\"error\", onError);\n      ws.addEventListener(\"open\", ev => {\n        if (!this.config) {\n          reject(\"Invalid config sent to `connect(config)`\");\n          return;\n        }\n        this.log(`client.${ev.type}`, `connected to socket`);\n        this.emit(\"open\");\n        this.ws = ws;\n        const setupMessage = {\n          setup: this.config\n        };\n        this._sendDirect(setupMessage);\n        this.log(\"client.send\", \"setup\");\n        ws.removeEventListener(\"error\", onError);\n        ws.addEventListener(\"close\", ev => {\n          console.log(ev);\n          this.disconnect(ws);\n          let reason = ev.reason || \"\";\n          if (reason.toLowerCase().includes(\"error\")) {\n            const prelude = \"ERROR]\";\n            const preludeIndex = reason.indexOf(prelude);\n            if (preludeIndex > 0) {\n              reason = reason.slice(preludeIndex + prelude.length + 1, Infinity);\n            }\n          }\n          this.log(`server.${ev.type}`, `disconnected ${reason ? `with reason: ${reason}` : ``}`);\n          this.emit(\"close\", ev);\n        });\n        resolve(true);\n      });\n    });\n  }\n  disconnect(ws) {\n    // could be that this is an old websocket and theres already a new instance\n    // only close it if its still the correct reference\n    if ((!ws || this.ws === ws) && this.ws) {\n      this.ws.close();\n      this.ws = null;\n      this.log(\"client.close\", `Disconnected`);\n      return true;\n    }\n    return false;\n  }\n  async receive(blob) {\n    const response = await blobToJSON(blob);\n    if (isToolCallMessage(response)) {\n      this.log(\"server.toolCall\", response);\n      this.emit(\"toolcall\", response.toolCall);\n      return;\n    }\n    if (isToolCallCancellationMessage(response)) {\n      this.log(\"receive.toolCallCancellation\", response);\n      this.emit(\"toolcallcancellation\", response.toolCallCancellation);\n      return;\n    }\n    if (isSetupCompleteMessage(response)) {\n      this.log(\"server.send\", \"setupComplete\");\n      this.emit(\"setupcomplete\");\n      return;\n    }\n\n    // this json also might be `contentUpdate { interrupted: true }`\n    // or contentUpdate { end_of_turn: true }\n    if (isServerContenteMessage(response)) {\n      const {\n        serverContent\n      } = response;\n      if (isInterrupted(serverContent)) {\n        this.log(\"receive.serverContent\", \"interrupted\");\n        this.emit(\"interrupted\");\n        return;\n      }\n      if (isTurnComplete(serverContent)) {\n        this.log(\"server.send\", \"turnComplete\");\n        this.emit(\"turncomplete\");\n        //plausible theres more to the message, continue\n      }\n      if (isModelTurn(serverContent)) {\n        let parts = serverContent.modelTurn.parts;\n\n        // when its audio that is returned for modelTurn\n        const audioParts = parts.filter(p => p.inlineData && p.inlineData.mimeType.startsWith(\"audio/pcm\"));\n        const base64s = audioParts.map(p => {\n          var _p$inlineData;\n          return (_p$inlineData = p.inlineData) === null || _p$inlineData === void 0 ? void 0 : _p$inlineData.data;\n        });\n\n        // strip the audio parts out of the modelTurn\n        const otherParts = difference(parts, audioParts);\n        // console.log(\"otherParts\", otherParts);\n\n        base64s.forEach(b64 => {\n          if (b64) {\n            const data = base64ToArrayBuffer(b64);\n            this.emit(\"audio\", data);\n            this.log(`server.audio`, `buffer (${data.byteLength})`);\n          }\n        });\n        if (!otherParts.length) {\n          return;\n        }\n        parts = otherParts;\n        const content = {\n          modelTurn: {\n            parts\n          }\n        };\n        this.emit(\"content\", content);\n        this.log(`server.content`, response);\n      }\n    } else {\n      console.log(\"received unmatched message\", response);\n    }\n  }\n\n  /**\r\n   * send realtimeInput, this is base64 chunks of \"audio/pcm\" and/or \"image/jpg\"\r\n   */\n  sendRealtimeInput(chunks) {\n    let hasAudio = false;\n    let hasVideo = false;\n    for (let i = 0; i < chunks.length; i++) {\n      const ch = chunks[i];\n      if (ch.mimeType.includes(\"audio\")) {\n        hasAudio = true;\n      }\n      if (ch.mimeType.includes(\"image\")) {\n        hasVideo = true;\n      }\n      if (hasAudio && hasVideo) {\n        break;\n      }\n    }\n    const message = hasAudio && hasVideo ? \"audio + video\" : hasAudio ? \"audio\" : hasVideo ? \"video\" : \"unknown\";\n    const data = {\n      realtimeInput: {\n        mediaChunks: chunks\n      }\n    };\n    this._sendDirect(data);\n    this.log(`client.realtimeInput`, message);\n  }\n\n  /**\r\n   *  send a response to a function call and provide the id of the functions you are responding to\r\n   */\n  sendToolResponse(toolResponse) {\n    const message = {\n      toolResponse\n    };\n    this._sendDirect(message);\n    this.log(`client.toolResponse`, message);\n  }\n\n  /**\r\n   * send normal content parts such as { text }\r\n   */\n  send(parts, turnComplete = true) {\n    parts = Array.isArray(parts) ? parts : [parts];\n    const content = {\n      role: \"user\",\n      parts\n    };\n    const clientContentRequest = {\n      clientContent: {\n        turns: [content],\n        turnComplete\n      }\n    };\n    this._sendDirect(clientContentRequest);\n    this.log(`client.send`, clientContentRequest);\n  }\n\n  /**\r\n   *  used internally to send all messages\r\n   *  don't use directly unless trying to send an unsupported message type\r\n   */\n  _sendDirect(request) {\n    if (!this.ws) {\n      throw new Error(\"WebSocket is not connected\");\n    }\n    const str = JSON.stringify(request);\n    this.ws.send(str);\n  }\n}","map":{"version":3,"names":["EventEmitter","difference","isInterrupted","isModelTurn","isServerContenteMessage","isSetupCompleteMessage","isToolCallCancellationMessage","isToolCallMessage","isTurnComplete","blobToJSON","base64ToArrayBuffer","MultimodalLiveClient","getConfig","config","constructor","url","apiKey","ws","send","bind","log","type","message","date","Date","emit","connect","WebSocket","addEventListener","evt","data","Blob","receive","console","Promise","resolve","reject","onError","ev","disconnect","Error","setupMessage","setup","_sendDirect","removeEventListener","reason","toLowerCase","includes","prelude","preludeIndex","indexOf","slice","length","Infinity","close","blob","response","toolCall","toolCallCancellation","serverContent","parts","modelTurn","audioParts","filter","p","inlineData","mimeType","startsWith","base64s","map","_p$inlineData","otherParts","forEach","b64","byteLength","content","sendRealtimeInput","chunks","hasAudio","hasVideo","i","ch","realtimeInput","mediaChunks","sendToolResponse","toolResponse","turnComplete","Array","isArray","role","clientContentRequest","clientContent","turns","request","str","JSON","stringify"],"sources":["C:/Users/prave/Repos/octane-erp/src/lib/multimodal-live-client.ts"],"sourcesContent":["/**\r\n * Copyright 2024 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { Content, GenerativeContentBlob, Part } from \"@google/generative-ai\";\r\nimport { EventEmitter } from \"eventemitter3\";\r\nimport { difference } from \"lodash\";\r\nimport {\r\n  ClientContentMessage,\r\n  isInterrupted,\r\n  isModelTurn,\r\n  isServerContenteMessage,\r\n  isSetupCompleteMessage,\r\n  isToolCallCancellationMessage,\r\n  isToolCallMessage,\r\n  isTurnComplete,\r\n  LiveIncomingMessage,\r\n  ModelTurn,\r\n  RealtimeInputMessage,\r\n  ServerContent,\r\n  SetupMessage,\r\n  StreamingLog,\r\n  ToolCall,\r\n  ToolCallCancellation,\r\n  ToolResponseMessage,\r\n  type LiveConfig,\r\n} from \"../multimodal-live-types\";\r\nimport { blobToJSON, base64ToArrayBuffer } from \"./utils\";\r\n\r\n/**\r\n * the events that this client will emit\r\n */\r\ninterface MultimodalLiveClientEventTypes {\r\n  open: () => void;\r\n  log: (log: StreamingLog) => void;\r\n  close: (event: CloseEvent) => void;\r\n  audio: (data: ArrayBuffer) => void;\r\n  content: (data: ServerContent) => void;\r\n  interrupted: () => void;\r\n  setupcomplete: () => void;\r\n  turncomplete: () => void;\r\n  toolcall: (toolCall: ToolCall) => void;\r\n  toolcallcancellation: (toolcallCancellation: ToolCallCancellation) => void;\r\n}\r\n\r\nexport type MultimodalLiveAPIClientConnection = {\r\n  url?: string;\r\n  apiKey: string;\r\n};\r\n\r\n/**\r\n * A event-emitting class that manages the connection to the websocket and emits\r\n * events to the rest of the application.\r\n * If you dont want to use react you can still use this.\r\n */\r\nexport class MultimodalLiveClient extends EventEmitter<MultimodalLiveClientEventTypes> {\r\n  public ws: WebSocket | null = null;\r\n  protected config: LiveConfig | null = null;\r\n  public url: string = \"\";\r\n  public getConfig() {\r\n    return { ...this.config };\r\n  }\r\n\r\n  constructor({ url, apiKey }: MultimodalLiveAPIClientConnection) {\r\n    super();\r\n    url =\r\n      url ||\r\n      `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent`;\r\n    url += `?key=${apiKey}`;\r\n    this.url = url;\r\n    this.send = this.send.bind(this);\r\n  }\r\n\r\n  log(type: string, message: StreamingLog[\"message\"]) {\r\n    const log: StreamingLog = {\r\n      date: new Date(),\r\n      type,\r\n      message,\r\n    };\r\n    this.emit(\"log\", log);\r\n  }\r\n\r\n  connect(config: LiveConfig): Promise<boolean> {\r\n    this.config = config;\r\n\r\n    const ws = new WebSocket(this.url);\r\n\r\n    ws.addEventListener(\"message\", async (evt: MessageEvent) => {\r\n      if (evt.data instanceof Blob) {\r\n        this.receive(evt.data);\r\n      } else {\r\n        console.log(\"non blob message\", evt);\r\n      }\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n      const onError = (ev: Event) => {\r\n        this.disconnect(ws);\r\n        const message = `Could not connect to \"${this.url}\"`;\r\n        this.log(`server.${ev.type}`, message);\r\n        reject(new Error(message));\r\n      };\r\n      ws.addEventListener(\"error\", onError);\r\n      ws.addEventListener(\"open\", (ev: Event) => {\r\n        if (!this.config) {\r\n          reject(\"Invalid config sent to `connect(config)`\");\r\n          return;\r\n        }\r\n        this.log(`client.${ev.type}`, `connected to socket`);\r\n        this.emit(\"open\");\r\n\r\n        this.ws = ws;\r\n\r\n        const setupMessage: SetupMessage = {\r\n          setup: this.config,\r\n        };\r\n        this._sendDirect(setupMessage);\r\n        this.log(\"client.send\", \"setup\");\r\n\r\n        ws.removeEventListener(\"error\", onError);\r\n        ws.addEventListener(\"close\", (ev: CloseEvent) => {\r\n          console.log(ev);\r\n          this.disconnect(ws);\r\n          let reason = ev.reason || \"\";\r\n          if (reason.toLowerCase().includes(\"error\")) {\r\n            const prelude = \"ERROR]\";\r\n            const preludeIndex = reason.indexOf(prelude);\r\n            if (preludeIndex > 0) {\r\n              reason = reason.slice(\r\n                preludeIndex + prelude.length + 1,\r\n                Infinity,\r\n              );\r\n            }\r\n          }\r\n          this.log(\r\n            `server.${ev.type}`,\r\n            `disconnected ${reason ? `with reason: ${reason}` : ``}`,\r\n          );\r\n          this.emit(\"close\", ev);\r\n        });\r\n        resolve(true);\r\n      });\r\n    });\r\n  }\r\n\r\n  disconnect(ws?: WebSocket) {\r\n    // could be that this is an old websocket and theres already a new instance\r\n    // only close it if its still the correct reference\r\n    if ((!ws || this.ws === ws) && this.ws) {\r\n      this.ws.close();\r\n      this.ws = null;\r\n      this.log(\"client.close\", `Disconnected`);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  protected async receive(blob: Blob) {\r\n    const response: LiveIncomingMessage = (await blobToJSON(\r\n      blob,\r\n    )) as LiveIncomingMessage;\r\n    if (isToolCallMessage(response)) {\r\n      this.log(\"server.toolCall\", response);\r\n      this.emit(\"toolcall\", response.toolCall);\r\n      return;\r\n    }\r\n    if (isToolCallCancellationMessage(response)) {\r\n      this.log(\"receive.toolCallCancellation\", response);\r\n      this.emit(\"toolcallcancellation\", response.toolCallCancellation);\r\n      return;\r\n    }\r\n\r\n    if (isSetupCompleteMessage(response)) {\r\n      this.log(\"server.send\", \"setupComplete\");\r\n      this.emit(\"setupcomplete\");\r\n      return;\r\n    }\r\n\r\n    // this json also might be `contentUpdate { interrupted: true }`\r\n    // or contentUpdate { end_of_turn: true }\r\n    if (isServerContenteMessage(response)) {\r\n      const { serverContent } = response;\r\n      if (isInterrupted(serverContent)) {\r\n        this.log(\"receive.serverContent\", \"interrupted\");\r\n        this.emit(\"interrupted\");\r\n        return;\r\n      }\r\n      if (isTurnComplete(serverContent)) {\r\n        this.log(\"server.send\", \"turnComplete\");\r\n        this.emit(\"turncomplete\");\r\n        //plausible theres more to the message, continue\r\n      }\r\n\r\n      if (isModelTurn(serverContent)) {\r\n        let parts: Part[] = serverContent.modelTurn.parts;\r\n\r\n        // when its audio that is returned for modelTurn\r\n        const audioParts = parts.filter(\r\n          (p) => p.inlineData && p.inlineData.mimeType.startsWith(\"audio/pcm\"),\r\n        );\r\n        const base64s = audioParts.map((p) => p.inlineData?.data);\r\n\r\n        // strip the audio parts out of the modelTurn\r\n        const otherParts = difference(parts, audioParts);\r\n        // console.log(\"otherParts\", otherParts);\r\n\r\n        base64s.forEach((b64) => {\r\n          if (b64) {\r\n            const data = base64ToArrayBuffer(b64);\r\n            this.emit(\"audio\", data);\r\n            this.log(`server.audio`, `buffer (${data.byteLength})`);\r\n          }\r\n        });\r\n        if (!otherParts.length) {\r\n          return;\r\n        }\r\n\r\n        parts = otherParts;\r\n\r\n        const content: ModelTurn = { modelTurn: { parts } };\r\n        this.emit(\"content\", content);\r\n        this.log(`server.content`, response);\r\n      }\r\n    } else {\r\n      console.log(\"received unmatched message\", response);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * send realtimeInput, this is base64 chunks of \"audio/pcm\" and/or \"image/jpg\"\r\n   */\r\n  sendRealtimeInput(chunks: GenerativeContentBlob[]) {\r\n    let hasAudio = false;\r\n    let hasVideo = false;\r\n    for (let i = 0; i < chunks.length; i++) {\r\n      const ch = chunks[i];\r\n      if (ch.mimeType.includes(\"audio\")) {\r\n        hasAudio = true;\r\n      }\r\n      if (ch.mimeType.includes(\"image\")) {\r\n        hasVideo = true;\r\n      }\r\n      if (hasAudio && hasVideo) {\r\n        break;\r\n      }\r\n    }\r\n    const message =\r\n      hasAudio && hasVideo\r\n        ? \"audio + video\"\r\n        : hasAudio\r\n          ? \"audio\"\r\n          : hasVideo\r\n            ? \"video\"\r\n            : \"unknown\";\r\n\r\n    const data: RealtimeInputMessage = {\r\n      realtimeInput: {\r\n        mediaChunks: chunks,\r\n      },\r\n    };\r\n    this._sendDirect(data);\r\n    this.log(`client.realtimeInput`, message);\r\n  }\r\n\r\n  /**\r\n   *  send a response to a function call and provide the id of the functions you are responding to\r\n   */\r\n  sendToolResponse(toolResponse: ToolResponseMessage[\"toolResponse\"]) {\r\n    const message: ToolResponseMessage = {\r\n      toolResponse,\r\n    };\r\n\r\n    this._sendDirect(message);\r\n    this.log(`client.toolResponse`, message);\r\n  }\r\n\r\n  /**\r\n   * send normal content parts such as { text }\r\n   */\r\n  send(parts: Part | Part[], turnComplete: boolean = true) {\r\n    parts = Array.isArray(parts) ? parts : [parts];\r\n    const content: Content = {\r\n      role: \"user\",\r\n      parts,\r\n    };\r\n\r\n    const clientContentRequest: ClientContentMessage = {\r\n      clientContent: {\r\n        turns: [content],\r\n        turnComplete,\r\n      },\r\n    };\r\n\r\n    this._sendDirect(clientContentRequest);\r\n    this.log(`client.send`, clientContentRequest);\r\n  }\r\n\r\n  /**\r\n   *  used internally to send all messages\r\n   *  don't use directly unless trying to send an unsupported message type\r\n   */\r\n  _sendDirect(request: object) {\r\n    if (!this.ws) {\r\n      throw new Error(\"WebSocket is not connected\");\r\n    }\r\n    const str = JSON.stringify(request);\r\n    this.ws.send(str);\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}