{"ast":null,"code":"import { getFormatMixins, isFieldOrDatumDef, isValueDef } from '../../../channeldef';\nimport { signalOrValueRef } from '../../common';\nimport { formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nexport function text(model, channel = 'text') {\n  const channelDef = model.encoding[channel];\n  return wrapCondition({\n    model,\n    channelDef,\n    vgChannel: channel,\n    mainRefFn: cDef => textRef(cDef, model.config),\n    invalidValueRef: undefined // text encoding doesn't have continuous scales and thus can't have invalid values\n  });\n}\nexport function textRef(channelDef, config, expr = 'datum') {\n  // text\n  if (channelDef) {\n    if (isValueDef(channelDef)) {\n      return signalOrValueRef(channelDef.value);\n    }\n    if (isFieldOrDatumDef(channelDef)) {\n      const {\n        format,\n        formatType\n      } = getFormatMixins(channelDef);\n      return formatSignalRef({\n        fieldOrDatumDef: channelDef,\n        format,\n        formatType,\n        expr,\n        config\n      });\n    }\n  }\n  return undefined;\n}","map":{"version":3,"names":["getFormatMixins","isFieldOrDatumDef","isValueDef","signalOrValueRef","formatSignalRef","wrapCondition","text","model","channel","channelDef","encoding","vgChannel","mainRefFn","cDef","textRef","config","invalidValueRef","undefined","expr","value","format","formatType","fieldOrDatumDef"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\client\\node_modules\\vega-lite\\src\\compile\\mark\\encode\\text.ts"],"sourcesContent":["import {getFormatMixins, isFieldOrDatumDef, isValueDef} from '../../../channeldef';\nimport {Config} from '../../../config';\nimport {Encoding} from '../../../encoding';\nimport {VgValueRef} from '../../../vega.schema';\nimport {signalOrValueRef} from '../../common';\nimport {formatSignalRef} from '../../format';\nimport {UnitModel} from '../../unit';\nimport {wrapCondition} from './conditional';\n\nexport function text(model: UnitModel, channel: 'text' | 'href' | 'url' | 'description' = 'text') {\n  const channelDef = model.encoding[channel];\n  return wrapCondition({\n    model,\n    channelDef,\n    vgChannel: channel,\n    mainRefFn: cDef => textRef(cDef, model.config),\n    invalidValueRef: undefined // text encoding doesn't have continuous scales and thus can't have invalid values\n  });\n}\n\nexport function textRef(\n  channelDef: Encoding<string>['text' | 'tooltip'],\n  config: Config,\n  expr: 'datum' | 'datum.datum' = 'datum'\n): VgValueRef {\n  // text\n  if (channelDef) {\n    if (isValueDef(channelDef)) {\n      return signalOrValueRef(channelDef.value);\n    }\n    if (isFieldOrDatumDef(channelDef)) {\n      const {format, formatType} = getFormatMixins(channelDef);\n      return formatSignalRef({fieldOrDatumDef: channelDef, format, formatType, expr, config});\n    }\n  }\n  return undefined;\n}\n"],"mappings":"AAAA,SAAQA,eAAe,EAAEC,iBAAiB,EAAEC,UAAU,QAAO,qBAAqB;AAIlF,SAAQC,gBAAgB,QAAO,cAAc;AAC7C,SAAQC,eAAe,QAAO,cAAc;AAE5C,SAAQC,aAAa,QAAO,eAAe;AAE3C,OAAM,SAAUC,IAAIA,CAACC,KAAgB,EAAEC,OAAA,GAAmD,MAAM;EAC9F,MAAMC,UAAU,GAAGF,KAAK,CAACG,QAAQ,CAACF,OAAO,CAAC;EAC1C,OAAOH,aAAa,CAAC;IACnBE,KAAK;IACLE,UAAU;IACVE,SAAS,EAAEH,OAAO;IAClBI,SAAS,EAAEC,IAAI,IAAIC,OAAO,CAACD,IAAI,EAAEN,KAAK,CAACQ,MAAM,CAAC;IAC9CC,eAAe,EAAEC,SAAS,CAAC;GAC5B,CAAC;AACJ;AAEA,OAAM,SAAUH,OAAOA,CACrBL,UAAgD,EAChDM,MAAc,EACdG,IAAA,GAAgC,OAAO;EAEvC;EACA,IAAIT,UAAU,EAAE;IACd,IAAIP,UAAU,CAACO,UAAU,CAAC,EAAE;MAC1B,OAAON,gBAAgB,CAACM,UAAU,CAACU,KAAK,CAAC;IAC3C;IACA,IAAIlB,iBAAiB,CAACQ,UAAU,CAAC,EAAE;MACjC,MAAM;QAACW,MAAM;QAAEC;MAAU,CAAC,GAAGrB,eAAe,CAACS,UAAU,CAAC;MACxD,OAAOL,eAAe,CAAC;QAACkB,eAAe,EAAEb,UAAU;QAAEW,MAAM;QAAEC,UAAU;QAAEH,IAAI;QAAEH;MAAM,CAAC,CAAC;IACzF;EACF;EACA,OAAOE,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}