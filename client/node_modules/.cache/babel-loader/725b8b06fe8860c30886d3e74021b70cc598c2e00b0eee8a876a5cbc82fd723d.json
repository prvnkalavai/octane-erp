{"ast":null,"code":"import { isString } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { channelDefType, isFieldDef, isFieldOrDatumDefForTimeFormat, isPositionFieldOrDatumDef, isScaleFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression } from '../timeunit';\nimport { QUANTITATIVE } from '../type';\nimport { stringify } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { datumDefToExpr } from './mark/encode/valueref';\nexport function isCustomFormatType(formatType) {\n  return formatType && formatType !== 'number' && formatType !== 'time';\n}\nfunction customFormatExpr(formatType, field, format) {\n  return `${formatType}(${field}${format ? `, ${stringify(format)}` : ''})`;\n}\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function formatSignalRef({\n  fieldOrDatumDef,\n  format,\n  formatType,\n  expr,\n  normalizeStack,\n  config\n}) {\n  if (isCustomFormatType(formatType)) {\n    return formatCustomType({\n      fieldOrDatumDef,\n      format,\n      formatType,\n      expr,\n      config\n    });\n  }\n  const field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n  const type = channelDefType(fieldOrDatumDef);\n  if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (type === 'quantitative') {\n      if (normalizeStack && config.normalizedNumberFormatType) return formatCustomType({\n        fieldOrDatumDef,\n        format: config.normalizedNumberFormat,\n        formatType: config.normalizedNumberFormatType,\n        expr,\n        config\n      });\n      if (config.numberFormatType) {\n        return formatCustomType({\n          fieldOrDatumDef,\n          format: config.numberFormat,\n          formatType: config.numberFormatType,\n          expr,\n          config\n        });\n      }\n    }\n    if (type === 'temporal' && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === undefined) {\n      return formatCustomType({\n        fieldOrDatumDef,\n        format: config.timeFormat,\n        formatType: config.timeFormatType,\n        expr,\n        config\n      });\n    }\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const signal = timeFormatExpression({\n      field,\n      timeUnit: isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined,\n      format,\n      formatType: config.timeFormatType,\n      rawTimeFormat: config.timeFormat,\n      isUTCScale: isScaleFieldDef(fieldOrDatumDef) && fieldOrDatumDef.scale?.type === ScaleType.UTC\n    });\n    return signal ? {\n      signal\n    } : undefined;\n  }\n  format = numberFormat({\n    type,\n    specifiedFormat: format,\n    config,\n    normalizeStack\n  });\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {\n      expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  } else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n    return {\n      signal: `${formatExpr(field, format)}`\n    };\n  } else {\n    return {\n      signal: `isValid(${field}) ? ${field} : \"\"+${field}`\n    };\n  }\n}\nfunction fieldToFormat(fieldOrDatumDef, expr, normalizeStack) {\n  if (isFieldDef(fieldOrDatumDef)) {\n    if (normalizeStack) {\n      return `${vgField(fieldOrDatumDef, {\n        expr,\n        suffix: 'end'\n      })}-${vgField(fieldOrDatumDef, {\n        expr,\n        suffix: 'start'\n      })}`;\n    } else {\n      return vgField(fieldOrDatumDef, {\n        expr\n      });\n    }\n  } else {\n    return datumDefToExpr(fieldOrDatumDef);\n  }\n}\nexport function formatCustomType({\n  fieldOrDatumDef,\n  format,\n  formatType,\n  expr,\n  normalizeStack,\n  config,\n  field\n}) {\n  field ?? (field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack));\n  if (field !== 'datum.value' &&\n  // For axis/legend, we can't correctly know the end of the bin from `datum`\n  isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {\n      expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  }\n  return {\n    signal: customFormatExpr(formatType, field, format)\n  };\n}\nexport function guideFormat(fieldOrDatumDef, type, format, formatType, config, omitTimeFormatConfig // axis doesn't use config.timeFormat\n) {\n  if (isString(formatType) && isCustomFormatType(formatType)) {\n    return undefined; // handled in encode block\n  } else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (channelDefType(fieldOrDatumDef) === 'quantitative') {\n      if (config.normalizedNumberFormatType && isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === 'normalize') {\n        return undefined; // handled in encode block\n      }\n      if (config.numberFormatType) {\n        return undefined; // handled in encode block\n      }\n    }\n  }\n  if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === 'normalize' && config.normalizedNumberFormat) {\n    return numberFormat({\n      type: 'quantitative',\n      config,\n      normalizeStack: true\n    });\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const timeUnit = isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined;\n    if (timeUnit === undefined && config.customFormatTypes && config.timeFormatType) {\n      return undefined; // hanlded in encode block\n    }\n    return timeFormat({\n      specifiedFormat: format,\n      timeUnit,\n      config,\n      omitTimeFormatConfig\n    });\n  }\n  return numberFormat({\n    type,\n    specifiedFormat: format,\n    config\n  });\n}\nexport function guideFormatType(formatType, fieldOrDatumDef, scaleType) {\n  if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n    return formatType;\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n    return isFieldDef(fieldOrDatumDef) && normalizeTimeUnit(fieldOrDatumDef?.timeUnit)?.utc ? 'utc' : 'time';\n  }\n  return undefined;\n}\n/**\n * Returns number format for a fieldDef.\n */\nexport function numberFormat({\n  type,\n  specifiedFormat,\n  config,\n  normalizeStack\n}) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (isString(specifiedFormat)) {\n    return specifiedFormat;\n  }\n  if (type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return normalizeStack ? config.normalizedNumberFormat : config.numberFormat;\n  }\n  return undefined;\n}\n/**\n * Returns time format for a fieldDef for use in guides.\n */\nexport function timeFormat({\n  specifiedFormat,\n  timeUnit,\n  config,\n  omitTimeFormatConfig\n}) {\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n  if (timeUnit) {\n    return {\n      signal: timeUnitSpecifierExpression(timeUnit)\n    };\n  }\n  return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\nfunction formatExpr(field, format) {\n  return `format(${field}, \"${format || ''}\")`;\n}\nfunction binNumberFormatExpr(field, format, formatType, config) {\n  if (isCustomFormatType(formatType)) {\n    return customFormatExpr(formatType, field, format);\n  }\n  return formatExpr(field, (isString(format) ? format : undefined) ?? config.numberFormat);\n}\nexport function binFormatExpression(startField, endField, format, formatType, config) {\n  if (format === undefined && formatType === undefined && config.customFormatTypes && config.numberFormatType) {\n    return binFormatExpression(startField, endField, config.numberFormat, config.numberFormatType, config);\n  }\n  const start = binNumberFormatExpr(startField, format, formatType, config);\n  const end = binNumberFormatExpr(endField, format, formatType, config);\n  return `${fieldValidPredicate(startField, false)} ? \"null\" : ${start} + \"${BIN_RANGE_DELIMITER}\" + ${end}`;\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression({\n  field,\n  timeUnit,\n  format,\n  formatType,\n  rawTimeFormat,\n  isUTCScale\n}) {\n  if (!timeUnit || format) {\n    // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n    if (!timeUnit && formatType) {\n      return `${formatType}(${field}, '${format}')`;\n    }\n    format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n    return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}","map":{"version":3,"names":["isString","isBinning","channelDefType","isFieldDef","isFieldOrDatumDefForTimeFormat","isPositionFieldOrDatumDef","isScaleFieldDef","vgField","fieldValidPredicate","ScaleType","formatExpression","normalizeTimeUnit","timeUnitSpecifierExpression","QUANTITATIVE","stringify","isSignalRef","datumDefToExpr","isCustomFormatType","formatType","customFormatExpr","field","format","BIN_RANGE_DELIMITER","formatSignalRef","fieldOrDatumDef","expr","normalizeStack","config","formatCustomType","fieldToFormat","type","undefined","customFormatTypes","normalizedNumberFormatType","normalizedNumberFormat","numberFormatType","numberFormat","timeFormatType","timeUnit","timeFormat","signal","timeFormatExpression","unit","rawTimeFormat","isUTCScale","scale","UTC","specifiedFormat","bin","endField","binSuffix","binFormatExpression","formatExpr","suffix","guideFormat","omitTimeFormatConfig","stack","guideFormatType","scaleType","utc","binNumberFormatExpr","startField","start","end"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\client\\node_modules\\vega-lite\\src\\compile\\format.ts"],"sourcesContent":["import type {SignalRef} from 'vega';\nimport {isString} from 'vega-util';\nimport {isBinning} from '../bin';\nimport {\n  channelDefType,\n  DatumDef,\n  FieldDef,\n  isFieldDef,\n  isFieldOrDatumDefForTimeFormat,\n  isPositionFieldOrDatumDef,\n  isScaleFieldDef,\n  vgField\n} from '../channeldef';\nimport {Config} from '../config';\nimport {fieldValidPredicate} from '../predicate';\nimport {ScaleType} from '../scale';\nimport {formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression} from '../timeunit';\nimport {QUANTITATIVE, Type} from '../type';\nimport {Dict, stringify} from '../util';\nimport {isSignalRef} from '../vega.schema';\nimport {TimeUnit} from './../timeunit';\nimport {datumDefToExpr} from './mark/encode/valueref';\n\nexport function isCustomFormatType(formatType: string) {\n  return formatType && formatType !== 'number' && formatType !== 'time';\n}\n\nfunction customFormatExpr(formatType: string, field: string, format: string | Dict<unknown>) {\n  return `${formatType}(${field}${format ? `, ${stringify(format)}` : ''})`;\n}\n\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\n\nexport function formatSignalRef({\n  fieldOrDatumDef,\n  format,\n  formatType,\n  expr,\n  normalizeStack,\n  config\n}: {\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>;\n  format: string | Dict<unknown>;\n  formatType: string;\n  expr?: 'datum' | 'parent' | 'datum.datum';\n  normalizeStack?: boolean;\n  config: Config;\n}) {\n  if (isCustomFormatType(formatType)) {\n    return formatCustomType({\n      fieldOrDatumDef,\n      format,\n      formatType,\n      expr,\n      config\n    });\n  }\n\n  const field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n  const type = channelDefType(fieldOrDatumDef);\n\n  if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (type === 'quantitative') {\n      if (normalizeStack && config.normalizedNumberFormatType)\n        return formatCustomType({\n          fieldOrDatumDef,\n          format: config.normalizedNumberFormat,\n          formatType: config.normalizedNumberFormatType,\n          expr,\n          config\n        });\n      if (config.numberFormatType) {\n        return formatCustomType({\n          fieldOrDatumDef,\n          format: config.numberFormat,\n          formatType: config.numberFormatType,\n          expr,\n          config\n        });\n      }\n    }\n    if (\n      type === 'temporal' &&\n      config.timeFormatType &&\n      isFieldDef(fieldOrDatumDef) &&\n      fieldOrDatumDef.timeUnit === undefined\n    ) {\n      return formatCustomType({\n        fieldOrDatumDef,\n        format: config.timeFormat,\n        formatType: config.timeFormatType,\n        expr,\n        config\n      });\n    }\n  }\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const signal = timeFormatExpression({\n      field,\n      timeUnit: isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined,\n      format,\n      formatType: config.timeFormatType,\n      rawTimeFormat: config.timeFormat,\n      isUTCScale: isScaleFieldDef(fieldOrDatumDef) && fieldOrDatumDef.scale?.type === ScaleType.UTC\n    });\n    return signal ? {signal} : undefined;\n  }\n\n  format = numberFormat({type, specifiedFormat: format, config, normalizeStack});\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    const endField = vgField(fieldOrDatumDef, {expr, binSuffix: 'end'});\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  } else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n    return {\n      signal: `${formatExpr(field, format)}`\n    };\n  } else {\n    return {signal: `isValid(${field}) ? ${field} : \"\"+${field}`};\n  }\n}\n\nfunction fieldToFormat(\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>,\n  expr: 'datum' | 'parent' | 'datum.datum',\n  normalizeStack: boolean\n) {\n  if (isFieldDef(fieldOrDatumDef)) {\n    if (normalizeStack) {\n      return `${vgField(fieldOrDatumDef, {expr, suffix: 'end'})}-${vgField(fieldOrDatumDef, {\n        expr,\n        suffix: 'start'\n      })}`;\n    } else {\n      return vgField(fieldOrDatumDef, {expr});\n    }\n  } else {\n    return datumDefToExpr(fieldOrDatumDef);\n  }\n}\n\nexport function formatCustomType({\n  fieldOrDatumDef,\n  format,\n  formatType,\n  expr,\n  normalizeStack,\n  config,\n  field\n}: {\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>;\n  format: string | Dict<unknown>;\n  formatType: string;\n  expr?: 'datum' | 'parent' | 'datum.datum';\n  normalizeStack?: boolean;\n  config: Config;\n  field?: string; // axis/legend \"use datum.value\"\n}) {\n  field ??= fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n\n  if (\n    field !== 'datum.value' && // For axis/legend, we can't correctly know the end of the bin from `datum`\n    isFieldDef(fieldOrDatumDef) &&\n    isBinning(fieldOrDatumDef.bin)\n  ) {\n    const endField = vgField(fieldOrDatumDef, {expr, binSuffix: 'end'});\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  }\n  return {signal: customFormatExpr(formatType, field, format)};\n}\n\nexport function guideFormat(\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>,\n  type: Type,\n  format: string | Dict<unknown>,\n  formatType: string | SignalRef,\n  config: Config,\n  omitTimeFormatConfig: boolean // axis doesn't use config.timeFormat\n) {\n  if (isString(formatType) && isCustomFormatType(formatType)) {\n    return undefined; // handled in encode block\n  } else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (channelDefType(fieldOrDatumDef) === 'quantitative') {\n      if (\n        config.normalizedNumberFormatType &&\n        isPositionFieldOrDatumDef(fieldOrDatumDef) &&\n        fieldOrDatumDef.stack === 'normalize'\n      ) {\n        return undefined; // handled in encode block\n      }\n      if (config.numberFormatType) {\n        return undefined; // handled in encode block\n      }\n    }\n  }\n\n  if (\n    isPositionFieldOrDatumDef(fieldOrDatumDef) &&\n    fieldOrDatumDef.stack === 'normalize' &&\n    config.normalizedNumberFormat\n  ) {\n    return numberFormat({\n      type: 'quantitative',\n      config,\n      normalizeStack: true\n    });\n  }\n\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    const timeUnit = isFieldDef(fieldOrDatumDef) ? normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit : undefined;\n    if (timeUnit === undefined && config.customFormatTypes && config.timeFormatType) {\n      return undefined; // hanlded in encode block\n    }\n\n    return timeFormat({specifiedFormat: format as string, timeUnit, config, omitTimeFormatConfig});\n  }\n\n  return numberFormat({type, specifiedFormat: format, config});\n}\n\nexport function guideFormatType(\n  formatType: string | SignalRef,\n  fieldOrDatumDef: FieldDef<string> | DatumDef<string>,\n  scaleType: ScaleType\n) {\n  if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n    return formatType;\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n    return isFieldDef(fieldOrDatumDef) && normalizeTimeUnit(fieldOrDatumDef?.timeUnit)?.utc ? 'utc' : 'time';\n  }\n  return undefined;\n}\n\n/**\n * Returns number format for a fieldDef.\n */\nexport function numberFormat({\n  type,\n  specifiedFormat,\n  config,\n  normalizeStack\n}: {\n  type: Type;\n  specifiedFormat?: string | Dict<unknown>;\n  config: Config;\n  normalizeStack?: boolean;\n}) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (isString(specifiedFormat)) {\n    return specifiedFormat;\n  }\n\n  if (type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return normalizeStack ? config.normalizedNumberFormat : config.numberFormat;\n  }\n  return undefined;\n}\n\n/**\n * Returns time format for a fieldDef for use in guides.\n */\nexport function timeFormat({\n  specifiedFormat,\n  timeUnit,\n  config,\n  omitTimeFormatConfig\n}: {\n  specifiedFormat?: string;\n  timeUnit?: TimeUnit;\n  config: Config;\n  omitTimeFormatConfig?: boolean;\n}) {\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (timeUnit) {\n    return {\n      signal: timeUnitSpecifierExpression(timeUnit)\n    };\n  }\n\n  return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\n\nfunction formatExpr(field: string, format: string) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nfunction binNumberFormatExpr(field: string, format: string | Dict<unknown>, formatType: string, config: Config) {\n  if (isCustomFormatType(formatType)) {\n    return customFormatExpr(formatType, field, format);\n  }\n\n  return formatExpr(field, (isString(format) ? format : undefined) ?? config.numberFormat);\n}\n\nexport function binFormatExpression(\n  startField: string,\n  endField: string,\n  format: string | Dict<unknown>,\n  formatType: string,\n  config: Config\n): string {\n  if (format === undefined && formatType === undefined && config.customFormatTypes && config.numberFormatType) {\n    return binFormatExpression(startField, endField, config.numberFormat, config.numberFormatType, config);\n  }\n  const start = binNumberFormatExpr(startField, format, formatType, config);\n  const end = binNumberFormatExpr(endField, format, formatType, config);\n  return `${fieldValidPredicate(startField, false)} ? \"null\" : ${start} + \"${BIN_RANGE_DELIMITER}\" + ${end}`;\n}\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression({\n  field,\n  timeUnit,\n  format,\n  formatType,\n  rawTimeFormat,\n  isUTCScale\n}: {\n  field: string;\n  timeUnit?: TimeUnit;\n  format?: string | Dict<unknown>;\n  formatType?: string;\n  rawTimeFormat?: string; // should be provided only for actual text and headers, not axis/legend labels\n  isUTCScale?: boolean;\n}): string {\n  if (!timeUnit || format) {\n    // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n    if (!timeUnit && formatType) {\n      return `${formatType}(${field}, '${format}')`;\n    }\n    format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n    return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}