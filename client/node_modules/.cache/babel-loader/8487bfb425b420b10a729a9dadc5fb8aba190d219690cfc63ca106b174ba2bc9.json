{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isConditionalAxisValue } from '../axis';\nimport { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldOrDatumDef, isTypedFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { initEncoding } from '../encoding';\nimport { replaceExprRef } from '../expr';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { isSelectionParameter } from '../selection';\nimport { isFrameMixins } from '../spec/base';\nimport { stack } from '../stack';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { signalOrValueRefWithCondition, signalRefOrValue } from './common';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { defaultFilled, initMarkdef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\nimport { CURR } from './selection/point';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n  constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {\n    super(spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n    this.specifiedScales = {};\n    this.specifiedAxes = {};\n    this.specifiedLegends = {};\n    this.specifiedProjection = {};\n    this.selection = [];\n    this.children = [];\n    /**\n     * Corrects the data references in marks after assemble.\n     */\n    this.correctDataNames = mark => {\n      // for normal data references\n      if (mark.from?.data) {\n        mark.from.data = this.lookupDataSource(mark.from.data);\n        if ('time' in this.encoding) {\n          mark.from.data = mark.from.data + CURR;\n        }\n      }\n      // for access to facet data\n      if (mark.from?.facet?.data) {\n        mark.from.facet.data = this.lookupDataSource(mark.from.facet.data);\n        // TOOD(jzong) uncomment this when it's time to implement facet animation\n        // if ('time' in this.encoding) {\n        //   mark.from.facet.data = mark.from.facet.data + CURR;\n        // }\n      }\n      return mark;\n    };\n    const markDef = isMarkDef(spec.mark) ? {\n      ...spec.mark\n    } : {\n      type: spec.mark\n    };\n    const mark = markDef.type;\n    // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n    if (markDef.filled === undefined) {\n      markDef.filled = defaultFilled(markDef, config, {\n        graticule: spec.data && isGraticuleGenerator(spec.data)\n      });\n    }\n    const encoding = this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config);\n    this.markDef = initMarkdef(markDef, encoding, config);\n    this.size = initLayoutSize({\n      encoding,\n      size: isFrameMixins(spec) ? {\n        ...parentGivenSize,\n        ...(spec.width ? {\n          width: spec.width\n        } : {}),\n        ...(spec.height ? {\n          height: spec.height\n        } : {})\n      } : parentGivenSize\n    });\n    // calculate stack properties\n    this.stack = stack(this.markDef, encoding);\n    this.specifiedScales = this.initScales(mark, encoding);\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegends(encoding);\n    this.specifiedProjection = spec.projection;\n    // Selections will be initialized upon parse.\n    this.selection = (spec.params ?? []).filter(p => isSelectionParameter(p));\n  }\n  get hasProjection() {\n    const {\n      encoding\n    } = this;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldOrDatumDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n  /**\n   * Return specified Vega-Lite scale domain for a particular channel\n   * @param channel\n   */\n  scaleDomain(channel) {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n  axis(channel) {\n    return this.specifiedAxes[channel];\n  }\n  legend(channel) {\n    return this.specifiedLegends[channel];\n  }\n  initScales(mark, encoding) {\n    return SCALE_CHANNELS.reduce((scales, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n      if (fieldOrDatumDef) {\n        scales[channel] = this.initScale(fieldOrDatumDef.scale ?? {});\n      }\n      return scales;\n    }, {});\n  }\n  initScale(scale) {\n    const {\n      domain,\n      range\n    } = scale;\n    // TODO: we could simplify this function if we had a recursive replace function\n    const scaleInternal = replaceExprRef(scale);\n    if (isArray(domain)) {\n      scaleInternal.domain = domain.map(signalRefOrValue);\n    }\n    if (isArray(range)) {\n      scaleInternal.range = range.map(signalRefOrValue);\n    }\n    return scaleInternal;\n  }\n  initAxes(encoding) {\n    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {\n      // Position Axis\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n      if (isFieldOrDatumDef(channelDef) || channel === X && isFieldOrDatumDef(encoding.x2) || channel === Y && isFieldOrDatumDef(encoding.y2)) {\n        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n        _axis[channel] = axisSpec ? this.initAxis({\n          ...axisSpec\n        }) // convert truthy value to object\n        : axisSpec;\n      }\n      return _axis;\n    }, {});\n  }\n  initAxis(axis) {\n    const props = keys(axis);\n    const axisInternal = {};\n    for (const prop of props) {\n      const val = axis[prop];\n      axisInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);\n    }\n    return axisInternal;\n  }\n  initLegends(encoding) {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n      if (fieldOrDatumDef && supportLegend(channel)) {\n        const legend = fieldOrDatumDef.legend;\n        _legend[channel] = legend ? replaceExprRef(legend) // convert truthy value to object\n        : legend;\n      }\n      return _legend;\n    }, {});\n  }\n  parseData() {\n    this.component.data = parseData(this);\n  }\n  parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n  parseSelections() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n  parseMarkGroup() {\n    this.component.mark = parseMarkGroups(this);\n  }\n  parseAxesAndHeaders() {\n    this.component.axes = parseUnitAxes(this);\n  }\n  assembleSelectionTopLevelSignals(signals) {\n    return assembleTopLevelSignals(this, signals);\n  }\n  assembleSignals() {\n    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n  }\n  assembleSelectionData(data) {\n    return assembleUnitSelectionData(this, data);\n  }\n  assembleLayout() {\n    return null;\n  }\n  assembleLayoutSignals() {\n    return assembleLayoutSignals(this);\n  }\n  assembleMarks() {\n    let marks = this.component.mark ?? [];\n    // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n    return marks.map(this.correctDataNames);\n  }\n  assembleGroupStyle() {\n    const {\n      style\n    } = this.view || {};\n    if (style !== undefined) {\n      return style;\n    }\n    if (this.encoding.x || this.encoding.y) {\n      return 'cell';\n    } else {\n      return 'view';\n    }\n  }\n  getMapping() {\n    return this.encoding;\n  }\n  get mark() {\n    return this.markDef.type;\n  }\n  channelHasField(channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n  fieldDef(channel) {\n    const channelDef = this.encoding[channel];\n    return getFieldDef(channelDef);\n  }\n  typedFieldDef(channel) {\n    const fieldDef = this.fieldDef(channel);\n    if (isTypedFieldDef(fieldDef)) {\n      return fieldDef;\n    }\n    return null;\n  }\n}","map":{"version":3,"names":["isArray","isConditionalAxisValue","GEOPOSITION_CHANNELS","NONPOSITION_SCALE_CHANNELS","POSITION_SCALE_CHANNELS","SCALE_CHANNELS","supportLegend","X","Y","getFieldDef","getFieldOrDatumDef","isFieldOrDatumDef","isTypedFieldDef","isGraticuleGenerator","vlEncoding","initEncoding","replaceExprRef","GEOSHAPE","isMarkDef","isSelectionParameter","isFrameMixins","stack","keys","assembleAxisSignals","parseUnitAxes","signalOrValueRefWithCondition","signalRefOrValue","parseData","assembleLayoutSignals","initLayoutSize","parseUnitLayoutSize","defaultFilled","initMarkdef","parseMarkGroups","isLayerModel","ModelWithField","assembleTopLevelSignals","assembleUnitSelectionData","assembleUnitSelectionMarks","assembleUnitSelectionSignals","parseUnitSelection","CURR","UnitModel","constructor","spec","parent","parentGivenName","parentGivenSize","config","undefined","view","specifiedScales","specifiedAxes","specifiedLegends","specifiedProjection","selection","children","correctDataNames","mark","from","data","lookupDataSource","encoding","facet","markDef","type","filled","graticule","size","width","height","initScales","initAxes","initLegends","projection","params","filter","p","hasProjection","isGeoShapeMark","hasGeoPosition","some","channel","scaleDomain","scale","domain","axis","legend","reduce","scales","fieldOrDatumDef","initScale","range","scaleInternal","map","_axis","channelDef","x2","y2","axisSpec","initAxis","props","axisInternal","prop","val","_legend","component","parseLayoutSize","parseSelections","parseMarkGroup","parseAxesAndHeaders","axes","assembleSelectionTopLevelSignals","signals","assembleSignals","assembleSelectionData","assembleLayout","assembleMarks","marks","assembleGroupStyle","style","x","y","getMapping","channelHasField","fieldDef","typedFieldDef"],"sources":["C:\\Users\\prave\\Repos\\octane-erp\\client\\node_modules\\vega-lite\\src\\compile\\unit.ts"],"sourcesContent":["import {NewSignal, SignalRef} from 'vega';\nimport {isArray} from 'vega-util';\nimport {Axis, AxisInternal, isConditionalAxisValue} from '../axis';\nimport {\n  Channel,\n  GEOPOSITION_CHANNELS,\n  NonPositionScaleChannel,\n  NONPOSITION_SCALE_CHANNELS,\n  PositionChannel,\n  POSITION_SCALE_CHANNELS,\n  ScaleChannel,\n  SCALE_CHANNELS,\n  SingleDefChannel,\n  supportLegend,\n  X,\n  Y\n} from '../channel';\nimport {\n  getFieldDef,\n  getFieldOrDatumDef,\n  isFieldOrDatumDef,\n  isTypedFieldDef,\n  MarkPropFieldOrDatumDef,\n  PositionFieldDef\n} from '../channeldef';\nimport {Config} from '../config';\nimport {isGraticuleGenerator} from '../data';\nimport * as vlEncoding from '../encoding';\nimport {Encoding, initEncoding} from '../encoding';\nimport {ExprRef, replaceExprRef} from '../expr';\nimport {LegendInternal} from '../legend';\nimport {GEOSHAPE, isMarkDef, Mark, MarkDef} from '../mark';\nimport {Projection} from '../projection';\nimport {Domain, Scale} from '../scale';\nimport {isSelectionParameter, SelectionParameter} from '../selection';\nimport {LayoutSizeMixins, NormalizedUnitSpec} from '../spec';\nimport {isFrameMixins} from '../spec/base';\nimport {stack, StackProperties} from '../stack';\nimport {keys} from '../util';\nimport {VgData, VgLayout, VgMarkGroup} from '../vega.schema';\nimport {assembleAxisSignals} from './axis/assemble';\nimport {AxisInternalIndex} from './axis/component';\nimport {parseUnitAxes} from './axis/parse';\nimport {signalOrValueRefWithCondition, signalRefOrValue} from './common';\nimport {parseData} from './data/parse';\nimport {assembleLayoutSignals} from './layoutsize/assemble';\nimport {initLayoutSize} from './layoutsize/init';\nimport {parseUnitLayoutSize} from './layoutsize/parse';\nimport {LegendInternalIndex} from './legend/component';\nimport {defaultFilled, initMarkdef} from './mark/init';\nimport {parseMarkGroups} from './mark/mark';\nimport {isLayerModel, Model, ModelWithField} from './model';\nimport {ScaleIndex} from './scale/component';\nimport {\n  assembleTopLevelSignals,\n  assembleUnitSelectionData,\n  assembleUnitSelectionMarks,\n  assembleUnitSelectionSignals\n} from './selection/assemble';\nimport {parseUnitSelection} from './selection/parse';\nimport {CURR} from './selection/point';\n\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n  public readonly markDef: MarkDef<Mark, SignalRef>;\n  public readonly encoding: Encoding<string>;\n\n  public readonly specifiedScales: ScaleIndex = {};\n\n  public readonly stack: StackProperties;\n\n  protected specifiedAxes: AxisInternalIndex = {};\n\n  protected specifiedLegends: LegendInternalIndex = {};\n\n  public specifiedProjection: Projection<ExprRef | SignalRef> = {};\n\n  public readonly selection: SelectionParameter[] = [];\n  public children: Model[] = [];\n\n  constructor(\n    spec: NormalizedUnitSpec,\n    parent: Model,\n    parentGivenName: string,\n    parentGivenSize: LayoutSizeMixins = {},\n    config: Config<SignalRef>\n  ) {\n    super(spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n\n    const markDef = isMarkDef(spec.mark) ? {...spec.mark} : {type: spec.mark};\n    const mark = markDef.type;\n\n    // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n    if (markDef.filled === undefined) {\n      markDef.filled = defaultFilled(markDef, config, {\n        graticule: spec.data && isGraticuleGenerator(spec.data)\n      });\n    }\n\n    const encoding = (this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config));\n    this.markDef = initMarkdef(markDef, encoding, config);\n\n    this.size = initLayoutSize({\n      encoding,\n      size: isFrameMixins(spec)\n        ? {\n            ...parentGivenSize,\n            ...(spec.width ? {width: spec.width} : {}),\n            ...(spec.height ? {height: spec.height} : {})\n          }\n        : parentGivenSize\n    });\n\n    // calculate stack properties\n    this.stack = stack(this.markDef, encoding);\n    this.specifiedScales = this.initScales(mark, encoding);\n\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegends(encoding);\n    this.specifiedProjection = spec.projection;\n\n    // Selections will be initialized upon parse.\n    this.selection = (spec.params ?? []).filter(p => isSelectionParameter(p)) as SelectionParameter[];\n  }\n\n  public get hasProjection(): boolean {\n    const {encoding} = this;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldOrDatumDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n\n  /**\n   * Return specified Vega-Lite scale domain for a particular channel\n   * @param channel\n   */\n  public scaleDomain(channel: ScaleChannel): Domain {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n\n  public axis(channel: PositionChannel): AxisInternal {\n    return (this.specifiedAxes as any)[channel];\n  }\n\n  public legend(channel: NonPositionScaleChannel): LegendInternal {\n    return this.specifiedLegends[channel];\n  }\n\n  private initScales(mark: Mark, encoding: Encoding<string>): ScaleIndex {\n    return SCALE_CHANNELS.reduce((scales, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as\n        | PositionFieldDef<string>\n        | MarkPropFieldOrDatumDef<string>;\n      if (fieldOrDatumDef) {\n        scales[channel] = this.initScale(fieldOrDatumDef.scale ?? {});\n      }\n      return scales;\n    }, {} as ScaleIndex);\n  }\n\n  private initScale(scale: Scale<ExprRef | SignalRef>): Scale<SignalRef> {\n    const {domain, range} = scale;\n    // TODO: we could simplify this function if we had a recursive replace function\n    const scaleInternal = replaceExprRef(scale);\n    if (isArray(domain)) {\n      scaleInternal.domain = domain.map(signalRefOrValue);\n    }\n    if (isArray(range)) {\n      scaleInternal.range = range.map(signalRefOrValue);\n    }\n    return scaleInternal as Scale<SignalRef>;\n  }\n\n  private initAxes(encoding: Encoding<string>): AxisInternalIndex {\n    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {\n      // Position Axis\n\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n      if (\n        isFieldOrDatumDef(channelDef) ||\n        (channel === X && isFieldOrDatumDef(encoding.x2)) ||\n        (channel === Y && isFieldOrDatumDef(encoding.y2))\n      ) {\n        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n\n        _axis[channel] = axisSpec\n          ? this.initAxis({...axisSpec}) // convert truthy value to object\n          : axisSpec;\n      }\n      return _axis;\n    }, {} as any);\n  }\n\n  private initAxis(axis: Axis<ExprRef | SignalRef>): Axis<SignalRef> {\n    const props = keys(axis);\n    const axisInternal: any = {};\n    for (const prop of props) {\n      const val = axis[prop];\n      axisInternal[prop] = isConditionalAxisValue<any, ExprRef | SignalRef>(val)\n        ? signalOrValueRefWithCondition<any>(val)\n        : signalRefOrValue(val);\n    }\n    return axisInternal;\n  }\n\n  private initLegends(encoding: Encoding<string>): LegendInternalIndex {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) as MarkPropFieldOrDatumDef<string>;\n\n      if (fieldOrDatumDef && supportLegend(channel)) {\n        const legend = fieldOrDatumDef.legend;\n        _legend[channel] = legend\n          ? replaceExprRef(legend) // convert truthy value to object\n          : legend;\n      }\n\n      return _legend;\n    }, {} as any);\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n  }\n\n  public parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n\n  public parseSelections() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  public parseMarkGroup() {\n    this.component.mark = parseMarkGroups(this);\n  }\n\n  public parseAxesAndHeaders() {\n    this.component.axes = parseUnitAxes(this);\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): NewSignal[] {\n    return assembleTopLevelSignals(this, signals);\n  }\n\n  public assembleSignals(): NewSignal[] {\n    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n  }\n\n  public assembleSelectionData(data: readonly VgData[]): VgData[] {\n    return assembleUnitSelectionData(this, data);\n  }\n\n  public assembleLayout(): VgLayout {\n    return null;\n  }\n\n  public assembleLayoutSignals(): NewSignal[] {\n    return assembleLayoutSignals(this);\n  }\n\n  /**\n   * Corrects the data references in marks after assemble.\n   */\n  public correctDataNames = (mark: VgMarkGroup) => {\n    // for normal data references\n    if (mark.from?.data) {\n      mark.from.data = this.lookupDataSource(mark.from.data);\n      if ('time' in this.encoding) {\n        mark.from.data = mark.from.data + CURR;\n      }\n    }\n\n    // for access to facet data\n    if (mark.from?.facet?.data) {\n      mark.from.facet.data = this.lookupDataSource(mark.from.facet.data);\n      // TOOD(jzong) uncomment this when it's time to implement facet animation\n      // if ('time' in this.encoding) {\n      //   mark.from.facet.data = mark.from.facet.data + CURR;\n      // }\n    }\n\n    return mark;\n  };\n\n  public assembleMarks() {\n    let marks = this.component.mark ?? [];\n\n    // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n\n    return marks.map(this.correctDataNames);\n  }\n  public assembleGroupStyle(): string | string[] {\n    const {style} = this.view || {};\n    if (style !== undefined) {\n      return style;\n    }\n    if (this.encoding.x || this.encoding.y) {\n      return 'cell';\n    } else {\n      return 'view';\n    }\n  }\n\n  protected getMapping() {\n    return this.encoding;\n  }\n\n  public get mark(): Mark {\n    return this.markDef.type;\n  }\n\n  public channelHasField(channel: Channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  public fieldDef(channel: SingleDefChannel) {\n    const channelDef = (this.encoding as any)[channel];\n    return getFieldDef<string>(channelDef);\n  }\n\n  public typedFieldDef(channel: SingleDefChannel) {\n    const fieldDef = this.fieldDef(channel);\n    if (isTypedFieldDef(fieldDef)) {\n      return fieldDef;\n    }\n    return null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}